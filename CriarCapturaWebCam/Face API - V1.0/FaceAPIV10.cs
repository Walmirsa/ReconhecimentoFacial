// Code generated by Microsoft (R) AutoRest Code Generator 0.16.0.0
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.

namespace CriarCapturaWebCam
{
    using System;
    using System.Linq;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Net;
    using System.Net.Http;
    using System.Net.Http.Headers;
    using System.Text;
    using System.Text.RegularExpressions;
    using System.Threading;
    using System.Threading.Tasks;
    using Microsoft.Rest;
    using Microsoft.Rest.Serialization;
    using Newtonsoft.Json;

    /// <summary>
    /// This API is currently available in:
    /// 
    /// * West US - westus.api.cognitive.microsoft.com
    /// * West US 2 - westus2.api.cognitive.microsoft.com
    /// * East US - eastus.api.cognitive.microsoft.com
    /// * East US 2 - eastus2.api.cognitive.microsoft.com
    /// * West Central US - westcentralus.api.cognitive.microsoft.com
    /// * South Central US - southcentralus.api.cognitive.microsoft.com
    /// * West Europe - westeurope.api.cognitive.microsoft.com
    /// * North Europe - northeurope.api.cognitive.microsoft.com
    /// * Southeast Asia - southeastasia.api.cognitive.microsoft.com
    /// * East Asia - eastasia.api.cognitive.microsoft.com
    /// * Australia East - australiaeast.api.cognitive.microsoft.com
    /// * Brazil South - brazilsouth.api.cognitive.microsoft.com
    /// </summary>
    public partial class FaceAPIV10 : ServiceClient<FaceAPIV10>, IFaceAPIV10
    {
        /// <summary>
        /// The base URI of the service.
        /// </summary>
        public Uri BaseUri { get; set; }

        /// <summary>
        /// Gets or sets json serialization settings.
        /// </summary>
        public JsonSerializerSettings SerializationSettings { get; private set; }

        /// <summary>
        /// Gets or sets json deserialization settings.
        /// </summary>
        public JsonSerializerSettings DeserializationSettings { get; private set; }        

        /// <summary>
        /// Subscription credentials which uniquely identify client subscription.
        /// </summary>
        public ServiceClientCredentials Credentials { get; private set; }

        /// <summary>
        /// Initializes a new instance of the FaceAPIV10 class.
        /// </summary>
        /// <param name='handlers'>
        /// Optional. The delegating handlers to add to the http client pipeline.
        /// </param>
        protected FaceAPIV10(params DelegatingHandler[] handlers) : base(handlers)
        {
            this.Initialize();
        }

        /// <summary>
        /// Initializes a new instance of the FaceAPIV10 class.
        /// </summary>
        /// <param name='rootHandler'>
        /// Optional. The http client handler used to handle http transport.
        /// </param>
        /// <param name='handlers'>
        /// Optional. The delegating handlers to add to the http client pipeline.
        /// </param>
        protected FaceAPIV10(HttpClientHandler rootHandler, params DelegatingHandler[] handlers) : base(rootHandler, handlers)
        {
            this.Initialize();
        }

        /// <summary>
        /// Initializes a new instance of the FaceAPIV10 class.
        /// </summary>
        /// <param name='baseUri'>
        /// Optional. The base URI of the service.
        /// </param>
        /// <param name='handlers'>
        /// Optional. The delegating handlers to add to the http client pipeline.
        /// </param>
        protected FaceAPIV10(Uri baseUri, params DelegatingHandler[] handlers) : this(handlers)
        {
            if (baseUri == null)
            {
                throw new ArgumentNullException("baseUri");
            }
            this.BaseUri = baseUri;
        }

        /// <summary>
        /// Initializes a new instance of the FaceAPIV10 class.
        /// </summary>
        /// <param name='baseUri'>
        /// Optional. The base URI of the service.
        /// </param>
        /// <param name='rootHandler'>
        /// Optional. The http client handler used to handle http transport.
        /// </param>
        /// <param name='handlers'>
        /// Optional. The delegating handlers to add to the http client pipeline.
        /// </param>
        protected FaceAPIV10(Uri baseUri, HttpClientHandler rootHandler, params DelegatingHandler[] handlers) : this(rootHandler, handlers)
        {
            if (baseUri == null)
            {
                throw new ArgumentNullException("baseUri");
            }
            this.BaseUri = baseUri;
        }

        /// <summary>
        /// Initializes a new instance of the FaceAPIV10 class.
        /// </summary>
        /// <param name='credentials'>
        /// Required. Subscription credentials which uniquely identify client subscription.
        /// </param>
        /// <param name='handlers'>
        /// Optional. The delegating handlers to add to the http client pipeline.
        /// </param>
        public FaceAPIV10(ServiceClientCredentials credentials, params DelegatingHandler[] handlers) : this(handlers)
        {
            if (credentials == null)
            {
                throw new ArgumentNullException("credentials");
            }
            this.Credentials = credentials;
            if (this.Credentials != null)
            {
                this.Credentials.InitializeServiceClient(this);
            }
        }

        /// <summary>
        /// Initializes a new instance of the FaceAPIV10 class.
        /// </summary>
        /// <param name='credentials'>
        /// Required. Subscription credentials which uniquely identify client subscription.
        /// </param>
        /// <param name='rootHandler'>
        /// Optional. The http client handler used to handle http transport.
        /// </param>
        /// <param name='handlers'>
        /// Optional. The delegating handlers to add to the http client pipeline.
        /// </param>
        public FaceAPIV10(ServiceClientCredentials credentials, HttpClientHandler rootHandler, params DelegatingHandler[] handlers) : this(rootHandler, handlers)
        {
            if (credentials == null)
            {
                throw new ArgumentNullException("credentials");
            }
            this.Credentials = credentials;
            if (this.Credentials != null)
            {
                this.Credentials.InitializeServiceClient(this);
            }
        }

        /// <summary>
        /// Initializes a new instance of the FaceAPIV10 class.
        /// </summary>
        /// <param name='baseUri'>
        /// Optional. The base URI of the service.
        /// </param>
        /// <param name='credentials'>
        /// Required. Subscription credentials which uniquely identify client subscription.
        /// </param>
        /// <param name='handlers'>
        /// Optional. The delegating handlers to add to the http client pipeline.
        /// </param>
        public FaceAPIV10(Uri baseUri, ServiceClientCredentials credentials, params DelegatingHandler[] handlers) : this(handlers)
        {
            if (baseUri == null)
            {
                throw new ArgumentNullException("baseUri");
            }
            if (credentials == null)
            {
                throw new ArgumentNullException("credentials");
            }
            this.BaseUri = baseUri;
            this.Credentials = credentials;
            if (this.Credentials != null)
            {
                this.Credentials.InitializeServiceClient(this);
            }
        }

        /// <summary>
        /// Initializes a new instance of the FaceAPIV10 class.
        /// </summary>
        /// <param name='baseUri'>
        /// Optional. The base URI of the service.
        /// </param>
        /// <param name='credentials'>
        /// Required. Subscription credentials which uniquely identify client subscription.
        /// </param>
        /// <param name='rootHandler'>
        /// Optional. The http client handler used to handle http transport.
        /// </param>
        /// <param name='handlers'>
        /// Optional. The delegating handlers to add to the http client pipeline.
        /// </param>
        public FaceAPIV10(Uri baseUri, ServiceClientCredentials credentials, HttpClientHandler rootHandler, params DelegatingHandler[] handlers) : this(rootHandler, handlers)
        {
            if (baseUri == null)
            {
                throw new ArgumentNullException("baseUri");
            }
            if (credentials == null)
            {
                throw new ArgumentNullException("credentials");
            }
            this.BaseUri = baseUri;
            this.Credentials = credentials;
            if (this.Credentials != null)
            {
                this.Credentials.InitializeServiceClient(this);
            }
        }

        /// <summary>
        /// An optional partial-method to perform custom initialization.
        ///</summary> 
        partial void CustomInitialize();
        /// <summary>
        /// Initializes client properties.
        /// </summary>
        private void Initialize()
        {
            this.BaseUri = new Uri("https://westus.api.cognitive.microsoft.com/face/v1.0");
            SerializationSettings = new JsonSerializerSettings
            {
                Formatting = Formatting.Indented,
                DateFormatHandling = DateFormatHandling.IsoDateFormat,
                DateTimeZoneHandling = DateTimeZoneHandling.Utc,
                NullValueHandling = NullValueHandling.Ignore,
                ReferenceLoopHandling = ReferenceLoopHandling.Serialize,
                ContractResolver = new ReadOnlyJsonContractResolver(),
                Converters = new List<JsonConverter>
                    {
                        new Iso8601TimeSpanConverter()
                    }
            };
            DeserializationSettings = new JsonSerializerSettings
            {
                DateFormatHandling = DateFormatHandling.IsoDateFormat,
                DateTimeZoneHandling = DateTimeZoneHandling.Utc,
                NullValueHandling = NullValueHandling.Ignore,
                ReferenceLoopHandling = ReferenceLoopHandling.Serialize,
                ContractResolver = new ReadOnlyJsonContractResolver(),
                Converters = new List<JsonConverter>
                    {
                        new Iso8601TimeSpanConverter()
                    }
            };
            CustomInitialize();
        }    
        /// <summary>
        /// Face - Detect
        /// </summary>
        /// Detect human faces in an image, return face rectangles, and optionally
        /// with faceIds, landmarks, and attributes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Optional parameters including faceId, landmarks, and
        /// attributes. Attributes include age, gender, headPose, smile, facialHair,
        /// glasses, emotion, hair, makeup, occlusion, accessories, blur,
        /// exposure and noise.&lt;/li&gt;
        /// &lt;li&gt;faceId will be used in
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239"&gt;Face
        /// - Identify&lt;/a&gt;,
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523a"&gt;Face
        /// - Verify&lt;/a&gt;, and
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237"&gt;Face
        /// - Find Similar&lt;/a&gt;. It will expire 24 hours after the detection
        /// call.&lt;/li&gt;
        /// &lt;li&gt;JPEG, PNG, GIF (the first frame), and BMP format are
        /// supported. The allowed image file size is from 1KB to 4MB.&lt;/li&gt;
        /// &lt;li&gt;Faces are detectable when its size is 36x36 to 4096x4096
        /// pixels. If need to detect very small but clear faces, please
        /// try to enlarge the input image.&lt;/li&gt;
        /// &lt;li&gt;Up to 64 faces can be returned for an image. Faces are
        /// ranked by face rectangle size from large to small.&lt;/li&gt;
        /// &lt;li&gt;Face detector prefer frontal and near-frontal faces. There
        /// are cases that faces may not be detected, e.g. exceptionally
        /// large face angles (head-pose) or being occluded, or wrong image
        /// orientation.&lt;/li&gt;
        /// &lt;li&gt;Attributes (age, gender, headPose, smile, facialHair,
        /// glasses, emotion, hair, makeup, occlusion, accessories, blur, exposure
        /// and noise) may not be perfectly accurate. HeadPose's pitch value
        /// is a reserved field and will always return 0.&lt;/li&gt;
        /// &lt;/ul&gt;
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// POST
        /// <param name='returnFaceId'>
        /// Return faceIds of the detected faces or not. The default value is true.
        /// </param>
        /// <param name='returnFaceLandmarks'>
        /// Return face landmarks of the detected faces or not. The default value is
        /// false.
        /// </param>
        /// <param name='returnFaceAttributes'>
        /// Analyze and return the one or more specified face attributes in the
        /// comma-separated string like "returnFaceAttributes=age,gender". Supported
        /// face attributes include age, gender, headPose, smile, facialHair,
        /// glasses, emotion, hair, makeup, occlusion, accessories, blur, exposure
        /// and noise. Face attribute analysis has additional computational and time
        /// cost.
        /// </param>
        /// <param name='body'>
        /// &lt;article class="ed_api_param"&gt;
        /// To detect in a URL (or binary data) specified image.
        /// &lt;br/&gt;&lt;br/&gt; JSON fields in the request body: &lt;br /&gt;
        /// &lt;table class="element table"&gt;
        /// &lt;thead&gt;
        /// &lt;tr&gt;&lt;th&gt;Fields&lt;/th&gt;&lt;th&gt;Type&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;
        /// &lt;/thead&gt;
        /// &lt;tbody&gt;
        /// &lt;tr&gt;&lt;td&gt;url&lt;/td&gt;&lt;th&gt;String&lt;/th&gt;&lt;td&gt;URL
        /// of input image.&lt;/td&gt;&lt;/tr&gt;
        /// 
        /// &lt;/tbody&gt;
        /// &lt;/table&gt;
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoThreeSixWithHttpMessagesAsync(bool? returnFaceId = true, bool? returnFaceLandmarks = false, string returnFaceAttributes = default(string), object body = default(object), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("returnFaceId", returnFaceId);
                tracingParameters.Add("returnFaceLandmarks", returnFaceLandmarks);
                tracingParameters.Add("returnFaceAttributes", returnFaceAttributes);
                tracingParameters.Add("body", body);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoThreeSix", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "detect").ToString();
            List<string> _queryParameters = new List<string>();
            if (returnFaceId != null)
            {
                _queryParameters.Add(string.Format("returnFaceId={0}", Uri.EscapeDataString(SafeJsonConvert.SerializeObject(returnFaceId, this.SerializationSettings).Trim('"'))));
            }
            if (returnFaceLandmarks != null)
            {
                _queryParameters.Add(string.Format("returnFaceLandmarks={0}", Uri.EscapeDataString(SafeJsonConvert.SerializeObject(returnFaceLandmarks, this.SerializationSettings).Trim('"'))));
            }
            if (returnFaceAttributes != null)
            {
                _queryParameters.Add(string.Format("returnFaceAttributes={0}", Uri.EscapeDataString(returnFaceAttributes)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("POST");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            if(body != null)
            {
                _requestContent = SafeJsonConvert.SerializeObject(body, this.SerializationSettings);
                _httpRequest.Content = new StringContent(_requestContent, Encoding.UTF8);
                _httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
            }
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 400 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 408 && (int)_statusCode != 415 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Face - Find Similar
        /// </summary>
        /// Given query face's faceId, to search the similar-looking faces from a
        /// faceId array, a face list or a large face list. faceId
        /// array contains the faces created by
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236"&gt;Face
        /// - Detect&lt;/a&gt;, which will expire 24 hours after creation. A
        /// "faceListId" is created by
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039524b"&gt;FaceList
        /// - Create&lt;/a&gt; containing persistedFaceIds that will not expire. And
        /// a "largeFaceListId" is created by
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/5a157b68d2de3616c086f2cc"&gt;LargeFaceList
        /// - Create&lt;/a&gt; containing persistedFaceIds that will also not expire.
        /// Depending on the input the returned similar
        /// faces list contains faceIds or persistedFaceIds ranked by similarity.
        /// &lt;br/&gt;
        /// &lt;br/&gt; Find similar has two working modes, "matchPerson" and
        /// "matchFace". "matchPerson" is the default mode that it tries to find
        /// faces of the same person as possible by using internal same-person
        /// thresholds. It is useful to find a known person's other
        /// photos. Note that an empty list will be returned if no faces pass the
        /// internal thresholds. "matchFace" mode ignores same-person
        /// thresholds and returns ranked similar faces anyway, even the similarity is
        /// low. It can be used in the cases like searching
        /// celebrity-looking faces.
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// POST
        /// <param name='body'>
        /// JSON fields in request body:
        /// &lt;table class="element table"&gt;
        /// &lt;thead&gt;
        /// &lt;tr&gt;
        /// &lt;th&gt;Fields&lt;/th&gt;
        /// &lt;th&gt;Type&lt;/th&gt;
        /// &lt;th&gt;Description&lt;/th&gt;
        /// &lt;/tr&gt;
        /// &lt;/thead&gt;
        /// &lt;tbody&gt;
        /// &lt;tr&gt;
        /// &lt;td&gt;faceId&lt;/td&gt;
        /// &lt;th&gt;String&lt;/th&gt;
        /// &lt;td&gt;faceId of the query face. User needs to call &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236"&gt;Face
        /// - Detect&lt;/a&gt; first to get a valid faceId. Note that this faceId is
        /// not persisted and will expire 24 hours after the detection
        /// call.&lt;/td&gt;
        /// &lt;/tr&gt;
        /// &lt;tr&gt;
        /// &lt;td&gt;faceListId&lt;/td&gt;
        /// &lt;th&gt;String&lt;/th&gt;
        /// &lt;td&gt;An existing user-specified unique candidate face
        /// list, created in &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039524b"&gt;FaceList
        /// - Create&lt;/a&gt;. Face list contains a set of persistedFaceIds which
        /// are persisted and will never expire. Parameter faceListId,
        /// largeFaceListId and faceIds should not be provided at the same
        /// time.&lt;/td&gt;
        /// &lt;/tr&gt;
        /// &lt;tr&gt;
        /// &lt;td&gt;largeFaceListId&lt;/td&gt;
        /// &lt;th&gt;String&lt;/th&gt;
        /// &lt;td&gt;An existing user-specified unique candidate large
        /// face list, created in &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/5a157b68d2de3616c086f2cc"&gt;LargeFaceList
        /// - Create&lt;/a&gt;. Large face list contains a set of persistedFaceIds
        /// which are persisted and will never expire. Parameter faceListId,
        /// largeFaceListId and faceIds should not be provided at the same
        /// time.&lt;/td&gt;
        /// &lt;/tr&gt;
        /// &lt;tr&gt;
        /// &lt;td&gt;faceIds&lt;/td&gt;
        /// &lt;th&gt;Array&lt;/th&gt;
        /// &lt;td&gt;An array of candidate faceIds. All of them are
        /// created by &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236"&gt;Face
        /// - Detect&lt;/a&gt; and the faceIds will expire 24 hours after the
        /// detection call. The number of faceIds is limited to 1000. Parameter
        /// faceListId, largeFaceListId and faceIds should not be provided at the
        /// same time.&lt;/td&gt;
        /// &lt;/tr&gt;
        /// &lt;tr&gt;
        /// &lt;td&gt;maxNumOfCandidatesReturned (optional)&lt;/td&gt;
        /// &lt;th&gt;Number&lt;/th&gt;
        /// &lt;td&gt;Optional parameter.
        /// &lt;br /&gt; The number of top similar faces returned.
        /// &lt;br /&gt; The valid range is [1, 1000].It defaults to
        /// 20. &lt;/td&gt;
        /// &lt;/tr&gt;
        /// &lt;tr&gt;
        /// &lt;td&gt;mode (optional)&lt;/td&gt;
        /// &lt;th&gt;String&lt;/th&gt;
        /// &lt;td&gt;Optional parameter.
        /// &lt;br /&gt; Similar face searching mode. It can be
        /// "matchPerson" or "matchFace". It defaults to "matchPerson".&lt;/td&gt;
        /// &lt;/tr&gt;
        /// &lt;/tbody&gt;
        /// &lt;/table&gt;
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoThreeSevenWithHttpMessagesAsync(object body = default(object), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("body", body);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoThreeSeven", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "findsimilars").ToString();
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("POST");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            if(body != null)
            {
                _requestContent = SafeJsonConvert.SerializeObject(body, this.SerializationSettings);
                _httpRequest.Content = new StringContent(_requestContent, Encoding.UTF8);
                _httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
            }
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 400 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 415 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Face - Group
        /// </summary>
        /// Divide candidate faces into groups based on face similarity.
        /// &lt;br/&gt;
        /// &lt;ul&gt;
        /// &lt;li&gt;The output is one or more disjointed face groups and a
        /// messyGroup. A face group contains faces
        /// that have similar looking, often of the same person. Face groups are
        /// ranked by
        /// group size, i.e. number of faces. Notice that faces belonging to a same
        /// person might be split into several groups in the result.
        /// &lt;/li&gt;
        /// &lt;li&gt;MessyGroup is a special face group containing faces that cannot
        /// find any similar counterpart face from original faces. The messyGroup
        /// will not appear in the result if all faces
        /// found their counterparts.&lt;/li&gt;
        /// &lt;li&gt;Group API needs at least 2 candidate faces and 1000 at most. We
        /// suggest to try &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523a"&gt;Face
        /// - Verify&lt;/a&gt; when you only have 2 candidate faces.&lt;/li&gt;
        /// &lt;/ul&gt;
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// POST
        /// <param name='body'>
        /// JSON fields in request body:
        /// &lt;table class="element table"&gt;
        /// &lt;thead&gt;
        /// &lt;tr&gt;&lt;th&gt;Fields&lt;/th&gt;&lt;th&gt;Type&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;
        /// &lt;/thead&gt;
        /// &lt;tbody&gt;
        /// &lt;tr&gt;&lt;td&gt;faceIds&lt;/td&gt;&lt;th&gt;Array&lt;/th&gt;&lt;td&gt;Array
        /// of candidate faceId created by &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236"&gt;Face
        /// - Detect&lt;/a&gt;. The maximum is 1000 faces.&lt;/td&gt;&lt;/tr&gt;
        /// 
        /// &lt;/tbody&gt;
        /// &lt;/table&gt;
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoThreeEightWithHttpMessagesAsync(object body = default(object), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("body", body);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoThreeEight", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "group").ToString();
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("POST");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            if(body != null)
            {
                _requestContent = SafeJsonConvert.SerializeObject(body, this.SerializationSettings);
                _httpRequest.Content = new StringContent(_requestContent, Encoding.UTF8);
                _httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
            }
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 400 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 415 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Face - Identify
        /// </summary>
        /// 1-to-many identification to find the closest matches of the specific query
        /// person face from a person group or large person group.
        /// &lt;br/&gt;
        /// &lt;br/&gt; For each face in the faceIds array, Face Identify will compute
        /// similarities between the query face and all the faces in
        /// the person group (given by personGroupId) or large person group (given by
        /// largePersonGroupId), and return candidate person(s)
        /// for that face ranked by similarity confidence. The person group/large
        /// person group should be trained to make it ready for
        /// identification. See more in
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395249"&gt;PersonGroup
        /// - Train&lt;/a&gt; and
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/599ae2d16ac60f11b48b5aa4"&gt;LargePersonGroup
        /// - Train&lt;/a&gt;.
        /// &lt;br/&gt;
        /// &lt;br/&gt; Remarks:
        /// &lt;ul&gt;
        /// &lt;li&gt;The algorithm allows more than one face to be identified
        /// independently at the same request, but no more than 10 faces.&lt;/li&gt;
        /// &lt;li&gt;Each person in the person group/large person group could have
        /// more than one face, but no more than 248 faces.&lt;/li&gt;
        /// &lt;li&gt;Identification works well for frontal faces and near-frontal
        /// faces.&lt;/li&gt;
        /// &lt;li&gt;Number of candidates returned is restricted by
        /// maxNumOfCandidatesReturned and confidenceThreshold. If no person is
        /// identified,
        /// the returned candidates will be an empty array.&lt;/li&gt;
        /// &lt;li&gt;Try
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237"&gt;Face
        /// - Find Similar&lt;/a&gt; when you need to find similar faces from a face
        /// list/large face list instead of a person group/large
        /// person group.&lt;/li&gt;
        /// &lt;/ul&gt;
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// POST
        /// <param name='body'>
        /// JSON fields in request body:
        /// &lt;table class="element table"&gt;
        /// &lt;thead&gt;
        /// &lt;tr&gt;
        /// &lt;th&gt;Fields&lt;/th&gt;
        /// &lt;th&gt;Type&lt;/th&gt;
        /// &lt;th&gt;Description&lt;/th&gt;
        /// &lt;/tr&gt;
        /// &lt;/thead&gt;
        /// &lt;tbody&gt;
        /// &lt;tr&gt;
        /// &lt;td&gt;faceIds&lt;/td&gt;
        /// &lt;th&gt;Array&lt;/th&gt;
        /// &lt;td&gt; Array of query faces faceIds, created by the &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236"&gt;Face
        /// - Detect&lt;/a&gt;. Each of the faces are identified independently. The
        /// valid number of faceIds is between [1, 10].&lt;/td&gt;
        /// &lt;/tr&gt;
        /// &lt;tr&gt;
        /// &lt;td&gt;personGroupId&lt;/td&gt;
        /// &lt;th&gt;String&lt;/th&gt;
        /// &lt;td&gt;personGroupId of the target person group, created by
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395244"&gt;PersonGroup
        /// - Create&lt;/a&gt;. Parameter personGroupId and largePersonGroupId should
        /// not be provided at the same time.&lt;/td&gt;
        /// &lt;/tr&gt;
        /// &lt;tr&gt;
        /// &lt;td&gt;largePersonGroupId&lt;/td&gt;
        /// &lt;th&gt;String&lt;/th&gt;
        /// &lt;td&gt;largePersonGroupId of the target large person group,
        /// created by &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/599acdee6ac60f11b48b5a9d"&gt;LargePersonGroup
        /// - Create&lt;/a&gt;. Parameter personGroupId and largePersonGroupId should
        /// not be provided at the same time.&lt;/td&gt;
        /// &lt;/tr&gt;
        /// &lt;tr&gt;
        /// &lt;td&gt;maxNumOfCandidatesReturned (optional)&lt;/td&gt;
        /// &lt;th&gt;Number&lt;/th&gt;
        /// &lt;td&gt;The range of maxNumOfCandidatesReturned is between 1
        /// and 100 (default is 10).&lt;/td&gt;
        /// &lt;/tr&gt;
        /// &lt;tr&gt;
        /// &lt;td&gt;confidenceThreshold (optional)&lt;/td&gt;
        /// &lt;th&gt;Number&lt;/th&gt;
        /// &lt;td&gt;Optional parameter.
        /// &lt;br /&gt; Customized identification confidence
        /// threshold, in the range of [0, 1]. Advanced user can tweak this value to
        /// override default internal threshold for better precision on their
        /// scenario data. Note there is no guarantee of this threshold value working
        /// on other data and after algorithm updates.&lt;/td&gt;
        /// &lt;/tr&gt;
        /// &lt;/tbody&gt;
        /// &lt;/table&gt;
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoThreeNineWithHttpMessagesAsync(object body = default(object), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("body", body);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoThreeNine", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "identify").ToString();
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("POST");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            if(body != null)
            {
                _requestContent = SafeJsonConvert.SerializeObject(body, this.SerializationSettings);
                _httpRequest.Content = new StringContent(_requestContent, Encoding.UTF8);
                _httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
            }
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 400 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 409 && (int)_statusCode != 415 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Face - Verify
        /// </summary>
        /// Verify whether two faces belong to a same person or whether one face
        /// belongs to a person.
        /// &lt;br/&gt;&lt;br/&gt;
        /// Remarks:
        /// &lt;ul&gt;
        /// &lt;li&gt;This API works well for frontal and near-frontal faces.
        /// &lt;/li&gt;
        /// &lt;li&gt;For the scenarios that are sensitive to accuracy please make
        /// your own judgment.&lt;/li&gt;
        /// &lt;/ul&gt;
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// POST
        /// <param name='body'>
        /// JSON fields in face to face verification request body:
        /// &lt;table class="element table"&gt;
        /// &lt;thead&gt;
        /// &lt;tr&gt;
        /// &lt;th&gt;Fields&lt;/th&gt;
        /// &lt;th&gt;Type&lt;/th&gt;
        /// &lt;th&gt;Description&lt;/th&gt;
        /// &lt;/tr&gt;
        /// &lt;/thead&gt;
        /// &lt;tbody&gt;
        /// &lt;tr&gt;
        /// &lt;td&gt;faceId1&lt;/td&gt;
        /// &lt;th&gt;String&lt;/th&gt;
        /// &lt;td&gt;faceId of one face, comes from
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236"&gt;Face
        /// - Detect&lt;/a&gt;.&lt;/td&gt;
        /// &lt;/tr&gt;
        /// &lt;tr&gt;
        /// &lt;td&gt;faceId2&lt;/td&gt;
        /// &lt;th&gt;String&lt;/th&gt;
        /// &lt;td&gt;faceId of another face, comes from
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236"&gt;Face
        /// - Detect&lt;/a&gt;.&lt;/td&gt;
        /// &lt;/tr&gt;
        /// &lt;/tbody&gt;
        /// &lt;/table&gt; JSON fields in face to person verification request body:
        /// &lt;table class="element table"&gt;
        /// &lt;thead&gt;
        /// &lt;tr&gt;
        /// &lt;th&gt;Fields&lt;/th&gt;
        /// &lt;th&gt;Type&lt;/th&gt;
        /// &lt;th&gt;Description&lt;/th&gt;
        /// &lt;/tr&gt;
        /// &lt;/thead&gt;
        /// &lt;tbody&gt;
        /// &lt;tr&gt;
        /// &lt;td&gt;faceId&lt;/td&gt;
        /// &lt;th&gt;String&lt;/th&gt;
        /// &lt;td&gt;faceId of the face, comes from
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236"&gt;Face
        /// - Detect&lt;/a&gt;.&lt;/td&gt;
        /// &lt;/tr&gt;
        /// &lt;tr&gt;
        /// &lt;td&gt;personGroupId&lt;/td&gt;
        /// &lt;th&gt;String&lt;/th&gt;
        /// &lt;td&gt;Using existing personGroupId and personId for fast loading a
        /// specified person. personGroupId is created in
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395244"&gt;PersonGroup
        /// - Create&lt;/a&gt;. Parameter personGroupId and largePersonGroupId should
        /// not be provided at the same time.&lt;/td&gt;
        /// &lt;/tr&gt;
        /// &lt;tr&gt;
        /// &lt;td&gt;largePersonGroupId&lt;/td&gt;
        /// &lt;th&gt;String&lt;/th&gt;
        /// &lt;td&gt;Using existing largePersonGroupId and personId for fast
        /// loading a specified person. largePersonGroupId is created in
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/599acdee6ac60f11b48b5a9d"&gt;LargePersonGroup
        /// - Create&lt;/a&gt;. Parameter personGroupId and largePersonGroupId should
        /// not be provided at the same time.&lt;/td&gt;
        /// &lt;/tr&gt;
        /// &lt;tr&gt;
        /// &lt;td&gt;personId&lt;/td&gt;
        /// &lt;th&gt;String&lt;/th&gt;
        /// &lt;td&gt;Specify a certain person in a person group or a large person
        /// group. personId is created in
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523c"&gt;PersonGroup
        /// Person - Create&lt;/a&gt; or
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/599adcba3a7b9412a4d53f40"&gt;LargePersonGroup
        /// Person - Create&lt;/a&gt;.&lt;/td&gt;
        /// &lt;/tr&gt;
        /// &lt;/tbody&gt;
        /// &lt;/table&gt;
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoThreeaWithHttpMessagesAsync(object body = default(object), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("body", body);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoThreea", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "verify").ToString();
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("POST");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            if(body != null)
            {
                _requestContent = SafeJsonConvert.SerializeObject(body, this.SerializationSettings);
                _httpRequest.Content = new StringContent(_requestContent, Encoding.UTF8);
                _httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
            }
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 400 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 415 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// PersonGroup Person - Add Face
        /// </summary>
        /// Add a face image to a person into a person group for face identification
        /// or verification. To deal with the image of multiple
        /// faces, input face can be specified as an image with a targetFace
        /// rectangle. It returns a persistedFaceId representing the
        /// added face. The face image and related info will be stored on server until
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523e"&gt;PersonGroup
        /// PersonFace - Delete&lt;/a&gt;,
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523d"&gt;PersonGroup
        /// Person - Delete&lt;/a&gt; or
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395245"&gt;PersonGroup
        /// - Delete&lt;/a&gt; is called.
        /// &lt;br /&gt; Note persistedFaceId is different from faceId generated by
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236"&gt;Face
        /// - Detect&lt;/a&gt;.
        /// &lt;ul&gt;
        /// &lt;li&gt;Higher face image quality means better recognition
        /// precision. Please consider high-quality faces: frontal, clear, and
        /// face size is 200x200 pixels (100 pixels between eyes) or
        /// bigger.&lt;/li&gt;
        /// &lt;li&gt;Each person entry can hold up to 248 faces.&lt;/li&gt;
        /// &lt;li&gt;JPEG, PNG, GIF (the first frame), and BMP format are
        /// supported. The allowed image file size is from 1KB to 4MB.&lt;/li&gt;
        /// &lt;li&gt;"targetFace" rectangle should contain one face. Zero or
        /// multiple faces will be regarded as an error. If the provided
        /// "targetFace" rectangle is not returned from
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236"&gt;Face
        /// - Detect&lt;/a&gt;, there’s no guarantee to detect and add the face
        /// successfully.&lt;/li&gt;
        /// &lt;li&gt;Out of detectable face size (36x36 - 4096x4096 pixels),
        /// large head-pose, or large occlusions will cause failures.&lt;/li&gt;
        /// &lt;li&gt;Adding/deleting faces to/from a same person will be
        /// processed sequentially. Adding/deleting faces to/from different persons
        /// are processed in parallel.&lt;/li&gt;
        /// &lt;/ul&gt;
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// POST
        /// <param name='personGroupId'>
        /// Specifying the person group containing the target person.
        /// </param>
        /// <param name='personId'>
        /// Target person that the face is added to.
        /// </param>
        /// <param name='userData'>
        /// User-specified data about the target face to add for any purpose. The
        /// maximum length is 1KB.
        /// </param>
        /// <param name='targetFace'>
        /// A face rectangle to specify the target face to be added to a person, in
        /// the format of "targetFace=left,top,width,height". E.g.
        /// "targetFace=10,10,100,100". If there is more than one face in the image,
        /// targetFace is required to specify which face to add. No targetFace means
        /// there is only one face detected in the entire image.
        /// </param>
        /// <param name='body'>
        /// 
        /// &lt;br/&gt;&lt;br/&gt; JSON fields in request body:
        /// &lt;table class="element table"&gt;
        /// &lt;thead&gt;
        /// &lt;tr&gt;&lt;th&gt;Fields&lt;/th&gt;&lt;th&gt;Type&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;
        /// &lt;/thead&gt;
        /// &lt;tbody&gt;
        /// &lt;tr&gt;&lt;td&gt;url&lt;/td&gt;&lt;th&gt;String&lt;/th&gt;&lt;td&gt;Face
        /// image URL. Valid image size is from 1KB to 4MB. Only one face is allowed
        /// per image.&lt;/td&gt;&lt;/tr&gt;
        /// 
        /// &lt;/tbody&gt;
        /// &lt;/table&gt;
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoThreebWithHttpMessagesAsync(string personGroupId, string personId, string userData = default(string), string targetFace = default(string), object body = default(object), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (personGroupId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "personGroupId");
            }
            if (personId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "personId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("personGroupId", personGroupId);
                tracingParameters.Add("personId", personId);
                tracingParameters.Add("userData", userData);
                tracingParameters.Add("targetFace", targetFace);
                tracingParameters.Add("body", body);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoThreeb", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "persongroups/{personGroupId}/persons/{personId}/persistedFaces").ToString();
            _url = _url.Replace("{personGroupId}", Uri.EscapeDataString(personGroupId));
            _url = _url.Replace("{personId}", Uri.EscapeDataString(personId));
            List<string> _queryParameters = new List<string>();
            if (userData != null)
            {
                _queryParameters.Add(string.Format("userData={0}", Uri.EscapeDataString(userData)));
            }
            if (targetFace != null)
            {
                _queryParameters.Add(string.Format("targetFace={0}", Uri.EscapeDataString(targetFace)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("POST");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            if(body != null)
            {
                _requestContent = SafeJsonConvert.SerializeObject(body, this.SerializationSettings);
                _httpRequest.Content = new StringContent(_requestContent, Encoding.UTF8);
                _httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
            }
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 400 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 408 && (int)_statusCode != 409 && (int)_statusCode != 415 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// PersonGroup Person - Create
        /// </summary>
        /// Create a new person in a specified person group. To add face to this
        /// person, please call
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523b"&gt;PersonGroup
        /// PersonFace - Add&lt;/a&gt;.
        /// &lt;br/&gt;
        /// &lt;ul&gt;
        /// &lt;li&gt;Free-tier subscription quota:
        /// &lt;ul&gt;
        /// &lt;li&gt;1,000 persons in all person groups.&lt;/li&gt;
        /// &lt;/ul&gt;
        /// &lt;/li&gt;
        /// &lt;li&gt;S0-tier subscription quota:
        /// &lt;ul&gt;
        /// &lt;li&gt;10,000 persons per person group.&lt;/li&gt;
        /// &lt;li&gt;1,000,000 person groups.&lt;/li&gt;
        /// &lt;li&gt;100,000,000 persons in all person groups.&lt;/li&gt;
        /// &lt;/ul&gt;
        /// &lt;/li&gt;
        /// &lt;/ul&gt;
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// POST
        /// <param name='personGroupId'>
        /// Specifying the target person group to create the person.
        /// </param>
        /// <param name='body'>
        /// 
        /// JSON fields in request body:
        /// &lt;table class="element table"&gt;
        /// &lt;thead&gt;
        /// &lt;tr&gt;&lt;th&gt;Fields&lt;/th&gt;&lt;th&gt;Type&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;
        /// &lt;/thead&gt;
        /// &lt;tbody&gt;
        /// &lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;th&gt;String&lt;/th&gt;&lt;td&gt;Display
        /// name of the target person. The maximum length is
        /// 128.&lt;/td&gt;&lt;/tr&gt;
        /// &lt;tr&gt;&lt;td&gt;userData
        /// (optional)&lt;/td&gt;&lt;th&gt;String&lt;/th&gt;&lt;td&gt;Optional fields
        /// for user-provided data attached to a person. Size limit is
        /// 16KB.&lt;/td&gt;&lt;/tr&gt;
        /// 
        /// &lt;/tbody&gt;
        /// &lt;/table&gt;
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoThreecWithHttpMessagesAsync(string personGroupId, object body = default(object), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (personGroupId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "personGroupId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("personGroupId", personGroupId);
                tracingParameters.Add("body", body);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoThreec", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "persongroups/{personGroupId}/persons").ToString();
            _url = _url.Replace("{personGroupId}", Uri.EscapeDataString(personGroupId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("POST");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            if(body != null)
            {
                _requestContent = SafeJsonConvert.SerializeObject(body, this.SerializationSettings);
                _httpRequest.Content = new StringContent(_requestContent, Encoding.UTF8);
                _httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
            }
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 400 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 409 && (int)_statusCode != 415 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// PersonGroup Person - List
        /// </summary>
        /// List all persons’ information in the specified person group, including
        /// personId, name, userData and persistedFaceIds of registered
        /// person faces.
        /// &lt;ul&gt;
        /// &lt;li&gt;Persons are stored in alphabetical order of personId created
        /// in
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523c"&gt;PersonGroup
        /// Person - Create&lt;/a&gt;.&lt;/li&gt;
        /// &lt;li&gt;"start" parameter (string, optional) is a personId value
        /// that returned entries have larger ids by string comparison.
        /// "start" set to empty to indicate return from the first
        /// item.&lt;/li&gt;
        /// &lt;li&gt;"top" parameter (int, optional) specifies the number of
        /// entries to return. A maximal of 1000 entries can be returned
        /// in one call. To fetch more, you can specify "start" with the last
        /// returned entry’s personId of the current call.&lt;/li&gt;
        /// &lt;/ul&gt;
        /// For example, total 5 persons with their personId: "personId1", ...,
        /// "personId5".
        /// &lt;br /&gt; "start=&amp;top=" will return all 5 persons.
        /// &lt;br /&gt; "start=&amp;top=2" will return "personId1", "personId2".
        /// &lt;br /&gt; "start=personId2&amp;top=3" will return "personId3",
        /// "personId4", "personId5".
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// GET
        /// <param name='personGroupId'>
        /// personGroupId of the target person group.
        /// </param>
        /// <param name='start'>
        /// List persons from the least personId greater than the "start". It contains
        /// no more than 64 characters. Default is empty.
        /// </param>
        /// <param name='top'>
        /// The number of persons to list, ranging in [1, 1000]. Default is 1000.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoFourOneWithHttpMessagesAsync(string personGroupId, string start = default(string), int? top = 1000, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (personGroupId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "personGroupId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("personGroupId", personGroupId);
                tracingParameters.Add("start", start);
                tracingParameters.Add("top", top);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoFourOne", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "persongroups/{personGroupId}/persons").ToString();
            _url = _url.Replace("{personGroupId}", Uri.EscapeDataString(personGroupId));
            List<string> _queryParameters = new List<string>();
            if (start != null)
            {
                _queryParameters.Add(string.Format("start={0}", Uri.EscapeDataString(start)));
            }
            if (top != null)
            {
                _queryParameters.Add(string.Format("top={0}", Uri.EscapeDataString(SafeJsonConvert.SerializeObject(top, this.SerializationSettings).Trim('"'))));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 409 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// PersonGroup Person - Delete
        /// </summary>
        /// Delete an existing person from a person group. All stored person data, and
        /// face images in the person entry will be deleted.
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// DELETE
        /// <param name='personGroupId'>
        /// Specifying the person group containing the person.
        /// </param>
        /// <param name='personId'>
        /// The target personId to delete.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoThreedWithHttpMessagesAsync(string personGroupId, string personId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (personGroupId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "personGroupId");
            }
            if (personId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "personId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("personGroupId", personGroupId);
                tracingParameters.Add("personId", personId);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoThreed", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "persongroups/{personGroupId}/persons/{personId}").ToString();
            _url = _url.Replace("{personGroupId}", Uri.EscapeDataString(personGroupId));
            _url = _url.Replace("{personId}", Uri.EscapeDataString(personId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("DELETE");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 409 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// PersonGroup Person - Get
        /// </summary>
        /// Retrieve a person's name and userData, and the persisted faceIds
        /// representing the registered person face image.
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// GET
        /// <param name='personGroupId'>
        /// Specifying the person group containing the target person.
        /// </param>
        /// <param name='personId'>
        /// Specifying the target person.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoThreefWithHttpMessagesAsync(string personGroupId, string personId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (personGroupId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "personGroupId");
            }
            if (personId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "personId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("personGroupId", personGroupId);
                tracingParameters.Add("personId", personId);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoThreef", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "persongroups/{personGroupId}/persons/{personId}").ToString();
            _url = _url.Replace("{personGroupId}", Uri.EscapeDataString(personGroupId));
            _url = _url.Replace("{personId}", Uri.EscapeDataString(personId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 409 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// PersonGroup Person - Update
        /// </summary>
        /// Update name or userData of a person.
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// PATCH
        /// <param name='personGroupId'>
        /// Specifying the person group containing the target person.
        /// </param>
        /// <param name='personId'>
        /// personId of the target person.
        /// </param>
        /// <param name='body'>
        /// 
        /// JSON fields in request body:
        /// &lt;table class="element table"&gt;
        /// &lt;thead&gt;
        /// &lt;tr&gt;&lt;th&gt;Fields&lt;/th&gt;&lt;th&gt;Type&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;
        /// &lt;/thead&gt;
        /// &lt;tbody&gt;
        /// &lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;th&gt;String&lt;/th&gt;&lt;td&gt;Target
        /// person's display name. Maximum length is 128.&lt;/td&gt;&lt;/tr&gt;
        /// &lt;tr&gt;&lt;td&gt;userData&lt;/td&gt;&lt;th&gt;String&lt;/th&gt;&lt;td&gt;User-provided
        /// data attached to the person. Maximum length is
        /// 16KB.&lt;/td&gt;&lt;/tr&gt;
        /// 
        /// &lt;/tbody&gt;
        /// &lt;/table&gt;
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoFourTwoWithHttpMessagesAsync(string personGroupId, string personId, object body = default(object), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (personGroupId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "personGroupId");
            }
            if (personId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "personId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("personGroupId", personGroupId);
                tracingParameters.Add("personId", personId);
                tracingParameters.Add("body", body);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoFourTwo", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "persongroups/{personGroupId}/persons/{personId}").ToString();
            _url = _url.Replace("{personGroupId}", Uri.EscapeDataString(personGroupId));
            _url = _url.Replace("{personId}", Uri.EscapeDataString(personId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("PATCH");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            if(body != null)
            {
                _requestContent = SafeJsonConvert.SerializeObject(body, this.SerializationSettings);
                _httpRequest.Content = new StringContent(_requestContent, Encoding.UTF8);
                _httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
            }
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 400 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 409 && (int)_statusCode != 415 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// PersonGroup Person - Delete Face
        /// </summary>
        /// Delete a face from a person in a person group. Face data and image related
        /// to this face entry will be also deleted.
        /// &lt;br /&gt; Adding/deleting faces to/from a same person will be processed
        /// sequentially. Adding/deleting faces to/from different persons are
        /// processed
        /// in parallel.
        /// &lt;br /&gt;
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// DELETE
        /// <param name='personGroupId'>
        /// Specifying the person group containing the target person.
        /// </param>
        /// <param name='personId'>
        /// Specifying the person that the target persisted face belong to.
        /// </param>
        /// <param name='persistedFaceId'>
        /// The persisted face to remove. This persistedFaceId is returned from &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523b"&gt;PersonGroup
        /// PersonFace - Add&lt;/a&gt;.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoThreeeWithHttpMessagesAsync(string personGroupId, string personId, string persistedFaceId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (personGroupId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "personGroupId");
            }
            if (personId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "personId");
            }
            if (persistedFaceId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "persistedFaceId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("personGroupId", personGroupId);
                tracingParameters.Add("personId", personId);
                tracingParameters.Add("persistedFaceId", persistedFaceId);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoThreee", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "persongroups/{personGroupId}/persons/{personId}/persistedFaces/{persistedFaceId}").ToString();
            _url = _url.Replace("{personGroupId}", Uri.EscapeDataString(personGroupId));
            _url = _url.Replace("{personId}", Uri.EscapeDataString(personId));
            _url = _url.Replace("{persistedFaceId}", Uri.EscapeDataString(persistedFaceId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("DELETE");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 409 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// PersonGroup Person - Get Face
        /// </summary>
        /// Retrieve person face information. The persisted person face is specified
        /// by its personGroupId, personId and persistedFaceId.
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// GET
        /// <param name='personGroupId'>
        /// Specifying the person group containing the target person.
        /// </param>
        /// <param name='personId'>
        /// Specifying the target person that the face belongs to.
        /// </param>
        /// <param name='persistedFaceId'>
        /// The persistedFaceId of the target persisted face of the person.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoFourZeroWithHttpMessagesAsync(string personGroupId, string personId, string persistedFaceId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (personGroupId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "personGroupId");
            }
            if (personId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "personId");
            }
            if (persistedFaceId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "persistedFaceId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("personGroupId", personGroupId);
                tracingParameters.Add("personId", personId);
                tracingParameters.Add("persistedFaceId", persistedFaceId);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoFourZero", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "persongroups/{personGroupId}/persons/{personId}/persistedFaces/{persistedFaceId}").ToString();
            _url = _url.Replace("{personGroupId}", Uri.EscapeDataString(personGroupId));
            _url = _url.Replace("{personId}", Uri.EscapeDataString(personId));
            _url = _url.Replace("{persistedFaceId}", Uri.EscapeDataString(persistedFaceId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 409 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// PersonGroup Person - Update Face
        /// </summary>
        /// Update a person persisted face's userData field.
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// PATCH
        /// <param name='personGroupId'>
        /// Specifying the person group containing the target person.
        /// </param>
        /// <param name='personId'>
        /// personId of the target person.
        /// </param>
        /// <param name='persistedFaceId'>
        /// persistedFaceId of target face, which is persisted and will not expire.
        /// </param>
        /// <param name='body'>
        /// 
        /// JSON fields in request body:
        /// &lt;table class="element table"&gt;
        /// &lt;thead&gt;
        /// &lt;tr&gt;&lt;th&gt;Fields&lt;/th&gt;&lt;th&gt;Type&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;
        /// &lt;/thead&gt;
        /// &lt;tbody&gt;
        /// &lt;tr&gt;&lt;td&gt;userData
        /// (optional)&lt;/td&gt;&lt;th&gt;String&lt;/th&gt;&lt;td&gt;Optional.
        /// Attach userData to person's persisted face. The size limit is
        /// 1KB.&lt;/td&gt;&lt;/tr&gt;
        /// 
        /// &lt;/tbody&gt;
        /// &lt;/table&gt;
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoFourThreeWithHttpMessagesAsync(string personGroupId, string personId, string persistedFaceId, object body = default(object), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (personGroupId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "personGroupId");
            }
            if (personId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "personId");
            }
            if (persistedFaceId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "persistedFaceId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("personGroupId", personGroupId);
                tracingParameters.Add("personId", personId);
                tracingParameters.Add("persistedFaceId", persistedFaceId);
                tracingParameters.Add("body", body);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoFourThree", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "persongroups/{personGroupId}/persons/{personId}/persistedFaces/{persistedFaceId}").ToString();
            _url = _url.Replace("{personGroupId}", Uri.EscapeDataString(personGroupId));
            _url = _url.Replace("{personId}", Uri.EscapeDataString(personId));
            _url = _url.Replace("{persistedFaceId}", Uri.EscapeDataString(persistedFaceId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("PATCH");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            if(body != null)
            {
                _requestContent = SafeJsonConvert.SerializeObject(body, this.SerializationSettings);
                _httpRequest.Content = new StringContent(_requestContent, Encoding.UTF8);
                _httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
            }
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 400 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 409 && (int)_statusCode != 415 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// PersonGroup - Create
        /// </summary>
        /// Create a new person group with specified personGroupId, name, and
        /// user-provided userData.
        /// &lt;br /&gt; A person group is the container of the uploaded person data,
        /// including face images and face recognition features.
        /// &lt;br /&gt; After creation, use
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523c"&gt;PersonGroup
        /// Person - Create&lt;/a&gt; to add persons into the group, and then call
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395249"&gt;PersonGroup
        /// - Train&lt;/a&gt; to get this group ready for
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239"&gt;Face
        /// - Identify&lt;/a&gt;.
        /// &lt;br /&gt; The person's face, image, and userData will be stored on
        /// server until
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039523d"&gt;PersonGroup
        /// Person - Delete&lt;/a&gt; or
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395245"&gt;PersonGroup
        /// - Delete&lt;/a&gt; is called.
        /// &lt;br /&gt;
        /// &lt;ul&gt;
        /// &lt;li&gt;Free-tier subscription quota: 1,000 person groups. Each
        /// holds up to 1,000 persons.&lt;/li&gt;
        /// &lt;li&gt;S0-tier subscription quota: 1,000,000 person groups. Each
        /// holds up to 10,000 persons.&lt;/li&gt;
        /// &lt;li&gt;to handle larger scale face identification problem, please
        /// consider using
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/599acdee6ac60f11b48b5a9d"&gt;LargePersonGroup&lt;/a&gt;.&lt;/li&gt;
        /// &lt;/ul&gt;
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// PUT
        /// <param name='personGroupId'>
        /// User-provided personGroupId as a string. The valid characters include
        /// numbers, English letters in lower case, '-' and '_'. The maximum length
        /// of the personGroupId is 64.
        /// </param>
        /// <param name='body'>
        /// 
        /// JSON fields in request body:
        /// &lt;table class="element table"&gt;
        /// &lt;thead&gt;
        /// &lt;tr&gt;&lt;th&gt;Fields&lt;/th&gt;&lt;th&gt;Type&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;
        /// &lt;/thead&gt;
        /// &lt;tbody&gt;
        /// &lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;th&gt;String&lt;/th&gt;&lt;td&gt;Person
        /// group display name. The maximum length is 128.&lt;/td&gt;&lt;/tr&gt;
        /// &lt;tr&gt;&lt;td&gt;userData
        /// (optional)&lt;/td&gt;&lt;th&gt;String&lt;/th&gt;&lt;td&gt;User-provided
        /// data attached to the person group. The size limit is
        /// 16KB.&lt;/td&gt;&lt;/tr&gt;
        /// 
        /// &lt;/tbody&gt;
        /// &lt;/table&gt;
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoFourFourWithHttpMessagesAsync(string personGroupId, object body = default(object), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (personGroupId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "personGroupId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("personGroupId", personGroupId);
                tracingParameters.Add("body", body);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoFourFour", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "persongroups/{personGroupId}").ToString();
            _url = _url.Replace("{personGroupId}", Uri.EscapeDataString(personGroupId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("PUT");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            if(body != null)
            {
                _requestContent = SafeJsonConvert.SerializeObject(body, this.SerializationSettings);
                _httpRequest.Content = new StringContent(_requestContent, Encoding.UTF8);
                _httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
            }
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 400 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 409 && (int)_statusCode != 415 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// PersonGroup - Delete
        /// </summary>
        /// Delete an existing person group with specified personGroupId. Persisted
        /// data in this person group will be deleted.
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// DELETE
        /// <param name='personGroupId'>
        /// The personGroupId of the person group to be deleted.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoFourFiveWithHttpMessagesAsync(string personGroupId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (personGroupId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "personGroupId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("personGroupId", personGroupId);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoFourFive", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "persongroups/{personGroupId}").ToString();
            _url = _url.Replace("{personGroupId}", Uri.EscapeDataString(personGroupId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("DELETE");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 409 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// PersonGroup - Get
        /// </summary>
        /// Retrieve person group name and userData. To get person information under
        /// this personGroup, use
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395241"&gt;PersonGroup
        /// Person - List&lt;/a&gt;.
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// GET
        /// <param name='personGroupId'>
        /// personGroupId of the target person group.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoFourSixWithHttpMessagesAsync(string personGroupId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (personGroupId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "personGroupId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("personGroupId", personGroupId);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoFourSix", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "persongroups/{personGroupId}").ToString();
            _url = _url.Replace("{personGroupId}", Uri.EscapeDataString(personGroupId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 409 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// PersonGroup - Update
        /// </summary>
        /// Update an existing person group's name and userData. The properties keep
        /// unchanged if they are not in request body.
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// PATCH
        /// <param name='personGroupId'>
        /// personGroupId of the person group to be updated.
        /// </param>
        /// <param name='body'>
        /// 
        /// JSON fields in request body:
        /// &lt;table class="element table"&gt;
        /// &lt;thead&gt;
        /// &lt;tr&gt;&lt;th&gt;Fields&lt;/th&gt;&lt;th&gt;Type&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;
        /// &lt;/thead&gt;
        /// &lt;tbody&gt;
        /// &lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;th&gt;String&lt;/th&gt;&lt;td&gt;Person
        /// group display name. The maximum length is 128.&lt;/td&gt;&lt;/tr&gt;
        /// &lt;tr&gt;&lt;td&gt;userData&lt;/td&gt;&lt;th&gt;String&lt;/th&gt;&lt;td&gt;User-provided
        /// data attached to the person group. The size limit is
        /// 16KB.&lt;/td&gt;&lt;/tr&gt;
        /// 
        /// &lt;/tbody&gt;
        /// &lt;/table&gt;
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoFouraWithHttpMessagesAsync(string personGroupId, object body = default(object), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (personGroupId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "personGroupId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("personGroupId", personGroupId);
                tracingParameters.Add("body", body);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoFoura", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "persongroups/{personGroupId}").ToString();
            _url = _url.Replace("{personGroupId}", Uri.EscapeDataString(personGroupId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("PATCH");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            if(body != null)
            {
                _requestContent = SafeJsonConvert.SerializeObject(body, this.SerializationSettings);
                _httpRequest.Content = new StringContent(_requestContent, Encoding.UTF8);
                _httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
            }
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 400 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 409 && (int)_statusCode != 415 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// PersonGroup - Get Training Status
        /// </summary>
        /// To check person group training status completed or still ongoing.
        /// PersonGroup Training is an asynchronous operation triggered
        /// by
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395249"&gt;PersonGroup
        /// - Train&lt;/a&gt; API.
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// GET
        /// <param name='personGroupId'>
        /// personGroupId of target person group.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoFourSevenWithHttpMessagesAsync(string personGroupId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (personGroupId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "personGroupId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("personGroupId", personGroupId);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoFourSeven", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "persongroups/{personGroupId}/training").ToString();
            _url = _url.Replace("{personGroupId}", Uri.EscapeDataString(personGroupId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 409 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// PersonGroup - List
        /// </summary>
        /// List person groups’s pesonGroupId, name, and userData.
        /// &lt;ul&gt;
        /// &lt;li&gt;Person groups are stored in alphabetical order of
        /// personGroupId.&lt;/li&gt;
        /// &lt;li&gt;"start" parameter (string, optional) is a user-provided
        /// personGroupId value that returned entries have larger ids by
        /// string comparison. "start" set to empty to indicate return from
        /// the first item.&lt;/li&gt;
        /// &lt;li&gt;"top" parameter (int, optional) specifies the number of
        /// entries to return. A maximal of 1000 entries can be returned
        /// in one call. To fetch more, you can specify "start" with the last
        /// retuned entry’s Id of the current call.&lt;/li&gt;
        /// &lt;/ul&gt;
        /// For example, total 5 person groups: "group1", ..., "group5".
        /// &lt;br /&gt; "start=&amp;top=" will return all 5 groups.
        /// &lt;br /&gt; "start=&amp;top=2" will return "group1", "group2".
        /// &lt;br /&gt; "start=group2&amp;top=3" will return "group3", "group4",
        /// "group5".
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// GET
        /// <param name='start'>
        /// List person groups from the least personGroupId greater than the "start".
        /// It contains no more than 64 characters. Default is empty.
        /// </param>
        /// <param name='top'>
        /// The number of person groups to list, ranging in [1, 1000]. Default is 1000.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoFourEightWithHttpMessagesAsync(string start = default(string), int? top = 1000, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("start", start);
                tracingParameters.Add("top", top);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoFourEight", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "persongroups").ToString();
            List<string> _queryParameters = new List<string>();
            if (start != null)
            {
                _queryParameters.Add(string.Format("start={0}", Uri.EscapeDataString(start)));
            }
            if (top != null)
            {
                _queryParameters.Add(string.Format("top={0}", Uri.EscapeDataString(SafeJsonConvert.SerializeObject(top, this.SerializationSettings).Trim('"'))));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 400 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 409 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// PersonGroup - Train
        /// </summary>
        /// Submit a person group training task. Training is a crucial step that only
        /// a trained person group can be used by
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239"&gt;Face
        /// - Identify&lt;/a&gt;.
        /// &lt;br /&gt;
        /// &lt;br /&gt; The training task is an asynchronous task. Training time
        /// depends on the number of person entries, and their faces in a person
        /// group. It could be several seconds to minutes. To check training status,
        /// please use
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395247"&gt;PersonGroup
        /// - Get Training Status&lt;/a&gt;.
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// POST
        /// <param name='personGroupId'>
        /// Target person group to be trained.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoFourNineWithHttpMessagesAsync(string personGroupId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (personGroupId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "personGroupId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("personGroupId", personGroupId);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoFourNine", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "persongroups/{personGroupId}/train").ToString();
            _url = _url.Replace("{personGroupId}", Uri.EscapeDataString(personGroupId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("POST");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 202 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 409 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// FaceList - Create
        /// </summary>
        /// Create an empty face list with user-specified faceListId, name and an
        /// optional userData. Up to 64 face lists are allowed
        /// in one subscription.
        /// &lt;br /&gt; Face list is a list of faces, up to 1,000 faces, and used by
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237"&gt;Face
        /// - Find Similar&lt;/a&gt;.
        /// &lt;br /&gt; After creation, user should use
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395250"&gt;FaceList
        /// - Add Face&lt;/a&gt; to import the faces. Faces are stored on server
        /// until
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039524f"&gt;FaceList
        /// - Delete&lt;/a&gt; is called.
        /// &lt;br /&gt; Find Similar is used for scenario like finding celebrity-like
        /// faces, similar face filtering, or as a light way face identification.
        /// But if the actual use is to identify person, please use
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395244"&gt;PersonGroup&lt;/a&gt;
        /// /
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/599acdee6ac60f11b48b5a9d"&gt;LargePersonGroup&lt;/a&gt;
        /// and
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239"&gt;Face
        /// - Identify&lt;/a&gt;.
        /// &lt;br /&gt; Please consider
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/5a157b68d2de3616c086f2cc"&gt;LargeFaceList&lt;/a&gt;
        /// when the face number is large. It can support up to 1,000,000 faces.
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// PUT
        /// <param name='faceListId'>
        /// Valid character is letter in lower case or digit or '-' or '_', maximum
        /// length is 64.
        /// </param>
        /// <param name='body'>
        /// 
        /// JSON fields in request body:
        /// &lt;table class="element table"&gt;
        /// &lt;thead&gt;
        /// &lt;tr&gt;&lt;th&gt;Fields&lt;/th&gt;&lt;th&gt;Type&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;
        /// &lt;/thead&gt;
        /// &lt;tbody&gt;
        /// &lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;th&gt;String&lt;/th&gt;&lt;td&gt;Name
        /// of the created face list, maximum length is 128.&lt;/td&gt;&lt;/tr&gt;
        /// &lt;tr&gt;&lt;td&gt;userData
        /// (optional)&lt;/td&gt;&lt;th&gt;String&lt;/th&gt;&lt;td&gt;Optional user
        /// defined data for the face list. Length should not exceed
        /// 16KB.&lt;/td&gt;&lt;/tr&gt;
        /// 
        /// &lt;/tbody&gt;
        /// &lt;/table&gt;
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoFourbWithHttpMessagesAsync(string faceListId, object body = default(object), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (faceListId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "faceListId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("faceListId", faceListId);
                tracingParameters.Add("body", body);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoFourb", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "facelists/{faceListId}").ToString();
            _url = _url.Replace("{faceListId}", Uri.EscapeDataString(faceListId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("PUT");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            if(body != null)
            {
                _requestContent = SafeJsonConvert.SerializeObject(body, this.SerializationSettings);
                _httpRequest.Content = new StringContent(_requestContent, Encoding.UTF8);
                _httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
            }
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 400 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 409 && (int)_statusCode != 415 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// FaceList - Get
        /// </summary>
        /// Retrieve a face list’s faceListId, name, userData and faces in the face
        /// list.
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// GET
        /// <param name='faceListId'>
        /// Valid character is letter in lower case or digit or '-' or '_', maximum
        /// length is 64.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoFourcWithHttpMessagesAsync(string faceListId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (faceListId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "faceListId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("faceListId", faceListId);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoFourc", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "facelists/{faceListId}").ToString();
            _url = _url.Replace("{faceListId}", Uri.EscapeDataString(faceListId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 409 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// FaceList - Update
        /// </summary>
        /// Update information of a face list, including name and userData.
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// PATCH
        /// <param name='faceListId'>
        /// Valid character is letter in lower case or digit or '-' or '_', maximum
        /// length is 64.
        /// </param>
        /// <param name='body'>
        /// 
        /// JSON fields in request body:
        /// &lt;table class="element table"&gt;
        /// &lt;thead&gt;
        /// &lt;tr&gt;&lt;th&gt;Fields&lt;/th&gt;&lt;th&gt;Type&lt;/th&gt;&lt;th&gt;Description&lt;/th&gt;&lt;/tr&gt;
        /// &lt;/thead&gt;
        /// &lt;tbody&gt;
        /// &lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;th&gt;String&lt;/th&gt;&lt;td&gt;Name
        /// of the face list, maximum length is 128&lt;/td&gt;&lt;/tr&gt;
        /// &lt;tr&gt;&lt;td&gt;userData
        /// (optional)&lt;/td&gt;&lt;th&gt;String&lt;/th&gt;&lt;td&gt;Optional user
        /// defined data for the face list. Length should not exceed
        /// 16KB&lt;/td&gt;&lt;/tr&gt;
        /// &lt;/tbody&gt;
        /// &lt;/table&gt;
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoFoureWithHttpMessagesAsync(string faceListId, object body = default(object), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (faceListId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "faceListId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("faceListId", faceListId);
                tracingParameters.Add("body", body);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoFoure", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "facelists/{faceListId}").ToString();
            _url = _url.Replace("{faceListId}", Uri.EscapeDataString(faceListId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("PATCH");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            if(body != null)
            {
                _requestContent = SafeJsonConvert.SerializeObject(body, this.SerializationSettings);
                _httpRequest.Content = new StringContent(_requestContent, Encoding.UTF8);
                _httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
            }
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 400 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 409 && (int)_statusCode != 415 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// FaceList - Delete
        /// </summary>
        /// Delete a specified face list. The related face images in the face list
        /// will be deleted, too.
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// DELETE
        /// <param name='faceListId'>
        /// Valid character is letter in lower case or digit or '-' or '_', maximum
        /// length is 64.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoFourfWithHttpMessagesAsync(string faceListId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (faceListId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "faceListId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("faceListId", faceListId);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoFourf", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "facelists/{faceListId}").ToString();
            _url = _url.Replace("{faceListId}", Uri.EscapeDataString(faceListId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("DELETE");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 409 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// FaceList - List
        /// </summary>
        /// List face lists’ faceListId, name and userData.
        /// &lt;br /&gt; To get face information inside faceList use
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039524c"&gt;FaceList
        /// - Get&lt;/a&gt;.
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// GET
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoFourdWithHttpMessagesAsync(Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoFourd", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "facelists").ToString();
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// FaceList - Add Face
        /// </summary>
        /// Add a face to a specified face list, up to 1,000 faces.
        /// &lt;br /&gt; To deal with the image of multiple faces, input face can be
        /// specified as an image with a targetFace rectangle. It returns
        /// a persistedFaceId representing the added face. The face image and related
        /// info will be stored on server until
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395251"&gt;FaceList
        /// - Delete Face&lt;/a&gt; or
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f3039524f"&gt;FaceList
        /// - Delete&lt;/a&gt; is called.
        /// &lt;br /&gt; Note persistedFaceId is different from faceId generated by
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236"&gt;Face
        /// - Detect&lt;/a&gt;.
        /// &lt;ul&gt;
        /// &lt;li&gt;JPEG, PNG, GIF (the first frame), and BMP format are
        /// supported. The allowed image file size is from 1KB to 4MB.&lt;/li&gt;
        /// &lt;li&gt;"targetFace" rectangle should contain one face. Zero or
        /// multiple faces will be regarded as an error. If the provided
        /// "targetFace" rectangle is not returned from
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236"&gt;Face
        /// - Detect&lt;/a&gt;, there’s no guarantee to detect and add the face
        /// successfully.&lt;/li&gt;
        /// &lt;li&gt;Out of detectable face size (36x36 - 4096x4096 pixels),
        /// large head-pose, or large occlusions will cause failures.&lt;/li&gt;
        /// &lt;li&gt;Adding/deleting faces to/from a same face list are processed
        /// sequentially and to/from different face lists are in parallel.&lt;/li&gt;
        /// &lt;/ul&gt;
        /// <param name='faceListId'>
        /// Valid character is letter in lower case or digit or '-' or '_', maximum
        /// length is 64.
        /// </param>
        /// <param name='userData'>
        /// User-specified data about the face list for any purpose. The maximum
        /// length is 1KB.
        /// </param>
        /// <param name='targetFace'>
        /// A face rectangle to specify the target face to be added into the face
        /// list, in the format of "targetFace=left,top,width,height". E.g.
        /// "targetFace=10,10,100,100". If there is more than one face in the image,
        /// targetFace is required to specify which face to add. No targetFace means
        /// there is only one face detected in the entire image.
        /// </param>
        /// <param name='body'>
        /// JSON fields in request body:
        /// &lt;table class="element table"&gt;
        /// &lt;thead&gt;
        /// &lt;tr&gt;
        /// &lt;th&gt;Fields&lt;/th&gt;
        /// &lt;th&gt;Type&lt;/th&gt;
        /// &lt;th&gt;Description&lt;/th&gt;
        /// &lt;/tr&gt;
        /// &lt;/thead&gt;
        /// &lt;tbody&gt;
        /// &lt;tr&gt;
        /// &lt;td&gt;url&lt;/td&gt;
        /// &lt;th&gt;String&lt;/th&gt;
        /// &lt;td&gt;Image url. Image file size should be between 1KB and 4MB.
        /// Only one face is allowed per image.&lt;/td&gt;
        /// &lt;/tr&gt;
        /// &lt;/tbody&gt;
        /// &lt;/table&gt;
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoFiveZeroWithHttpMessagesAsync(string faceListId, string userData = default(string), string targetFace = default(string), object body = default(object), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (faceListId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "faceListId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("faceListId", faceListId);
                tracingParameters.Add("userData", userData);
                tracingParameters.Add("targetFace", targetFace);
                tracingParameters.Add("body", body);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoFiveZero", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "facelists/{faceListId}/persistedFaces").ToString();
            _url = _url.Replace("{faceListId}", Uri.EscapeDataString(faceListId));
            List<string> _queryParameters = new List<string>();
            if (userData != null)
            {
                _queryParameters.Add(string.Format("userData={0}", Uri.EscapeDataString(userData)));
            }
            if (targetFace != null)
            {
                _queryParameters.Add(string.Format("targetFace={0}", Uri.EscapeDataString(targetFace)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("POST");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            if(body != null)
            {
                _requestContent = SafeJsonConvert.SerializeObject(body, this.SerializationSettings);
                _httpRequest.Content = new StringContent(_requestContent, Encoding.UTF8);
                _httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
            }
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 400 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 408 && (int)_statusCode != 409 && (int)_statusCode != 415 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// FaceList - Delete Face
        /// </summary>
        /// Delete a face from a face list by specified faceListId and
        /// persisitedFaceId. The related face image will be deleted, too.
        /// &lt;br /&gt; Adding/deleting faces to/from a same face list are processed
        /// sequentially and to/from different face lists are in parallel.
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// DELETE
        /// <param name='faceListId'>
        /// faceListId of an existing face list. Valid character is letter in lower
        /// case or digit or '-' or '_', maximum length is 64.
        /// </param>
        /// <param name='persistedFaceId'>
        /// persistedFaceId of an existing face. Valid character is letter in lower
        /// case or digit or '-' or '_', maximum length is 64.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoFiveOneWithHttpMessagesAsync(string faceListId, string persistedFaceId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (faceListId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "faceListId");
            }
            if (persistedFaceId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "persistedFaceId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("faceListId", faceListId);
                tracingParameters.Add("persistedFaceId", persistedFaceId);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveSixThreeEightSevenNinebSixOneNineEightFourFiveFiveZerofThreeZeroThreeNineFiveTwoFiveOne", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "facelists/{faceListId}/persistedFaces/{persistedFaceId}").ToString();
            _url = _url.Replace("{faceListId}", Uri.EscapeDataString(faceListId));
            _url = _url.Replace("{persistedFaceId}", Uri.EscapeDataString(persistedFaceId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("DELETE");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 409 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// LargePersonGroup - Create
        /// </summary>
        /// Create a new large person group with user-specified largePersonGroupId,
        /// name, and optional userData.
        /// &lt;br /&gt; A large person group is the container of the uploaded person
        /// data, including face images and face recognition feature, and up to
        /// 1,000,000
        /// people.
        /// &lt;br /&gt; After creation, use
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/599adcba3a7b9412a4d53f40"&gt;LargePersonGroup
        /// Person - Create&lt;/a&gt; to add person into the group, and call
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/599ae2d16ac60f11b48b5aa4"&gt;LargePersonGroup
        /// - Train&lt;/a&gt; to get this group ready for
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239"&gt;Face
        /// - Identify&lt;/a&gt;.
        /// &lt;br /&gt; The person face, image, and userData will be stored on server
        /// until
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/599ade5c6ac60f11b48b5aa2"&gt;LargePersonGroup
        /// Person - Delete&lt;/a&gt; or
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/599adc216ac60f11b48b5a9f"&gt;LargePersonGroup
        /// - Delete&lt;/a&gt; is called.
        /// &lt;br /&gt;
        /// &lt;ul&gt;
        /// &lt;li&gt;Free-tier subscription quota: 1,000 large person
        /// groups.&lt;/li&gt;
        /// &lt;li&gt;S0-tier subscription quota: 1,000,000 large person
        /// groups.&lt;/li&gt;
        /// &lt;/ul&gt;
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// PUT
        /// <param name='largePersonGroupId'>
        /// User-provided largePersonGroupId as a string. The valid characters include
        /// numbers, English letters in lower case, '-' and '_'. The maximum length
        /// of the largePersonGroupId is 64.
        /// </param>
        /// <param name='body'>
        /// JSON fields in request body:
        /// &lt;table class="element table"&gt;
        /// &lt;thead&gt;
        /// &lt;tr&gt;
        /// &lt;th&gt;Fields&lt;/th&gt;
        /// &lt;th&gt;Type&lt;/th&gt;
        /// &lt;th&gt;Description&lt;/th&gt;
        /// &lt;/tr&gt;
        /// &lt;/thead&gt;
        /// &lt;tbody&gt;
        /// &lt;tr&gt;
        /// &lt;td&gt;name&lt;/td&gt;
        /// &lt;th&gt;String&lt;/th&gt;
        /// &lt;td&gt;Name of the created large person group, maximum
        /// length is 128.&lt;/td&gt;
        /// &lt;/tr&gt;
        /// &lt;tr&gt;
        /// &lt;td&gt;userData (optional)&lt;/td&gt;
        /// &lt;th&gt;String&lt;/th&gt;
        /// &lt;td&gt;Optional user defined data for the large person
        /// group. Length should not exceed 16KB.&lt;/td&gt;
        /// &lt;/tr&gt;
        /// &lt;/tbody&gt;
        /// &lt;/table&gt;
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveNineNineacdeeSixacSixZerofOneOnebFourEightbFiveaNinedWithHttpMessagesAsync(string largePersonGroupId, object body = default(object), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (largePersonGroupId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "largePersonGroupId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("largePersonGroupId", largePersonGroupId);
                tracingParameters.Add("body", body);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveNineNineacdeeSixacSixZerofOneOnebFourEightbFiveaNined", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "largepersongroups/{largePersonGroupId}").ToString();
            _url = _url.Replace("{largePersonGroupId}", Uri.EscapeDataString(largePersonGroupId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("PUT");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            if(body != null)
            {
                _requestContent = SafeJsonConvert.SerializeObject(body, this.SerializationSettings);
                _httpRequest.Content = new StringContent(_requestContent, Encoding.UTF8);
                _httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
            }
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 400 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 409 && (int)_statusCode != 415 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// LargePersonGroup - Get
        /// </summary>
        /// Retrieve the information of a large person group, including its name and
        /// userData. This API returns large person group information
        /// only, use
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/599adda06ac60f11b48b5aa1"&gt;LargePersonGroup
        /// Person - List&lt;/a&gt; instead to retrieve person information under the
        /// large person group.
        /// &lt;h4&gt;Http Method&lt;/h4&gt; GET
        /// <param name='largePersonGroupId'>
        /// largePersonGroupId of the target large person group.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveNineNineacebbSixacSixZerofOneOnebFourEightbFiveaNineeWithHttpMessagesAsync(string largePersonGroupId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (largePersonGroupId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "largePersonGroupId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("largePersonGroupId", largePersonGroupId);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveNineNineacebbSixacSixZerofOneOnebFourEightbFiveaNinee", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "largepersongroups/{largePersonGroupId}").ToString();
            _url = _url.Replace("{largePersonGroupId}", Uri.EscapeDataString(largePersonGroupId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// LargePersonGroup - Update
        /// </summary>
        /// Update an existing large person group's name and userData. The properties
        /// keep unchanged if they are not in request body.
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// PATCH
        /// <param name='largePersonGroupId'>
        /// largePersonGroupId of the target large person group.
        /// </param>
        /// <param name='body'>
        /// JSON fields in request body:
        /// &lt;table class="element table"&gt;
        /// &lt;thead&gt;
        /// &lt;tr&gt;
        /// &lt;th&gt;Fields&lt;/th&gt;
        /// &lt;th&gt;Type&lt;/th&gt;
        /// &lt;th&gt;Description&lt;/th&gt;
        /// &lt;/tr&gt;
        /// &lt;/thead&gt;
        /// &lt;tbody&gt;
        /// &lt;tr&gt;
        /// &lt;td&gt;name&lt;/td&gt;
        /// &lt;th&gt;String&lt;/th&gt;
        /// &lt;td&gt;Name of the created large person group, maximum
        /// length is 128.&lt;/td&gt;
        /// &lt;/tr&gt;
        /// &lt;tr&gt;
        /// &lt;td&gt;userData (optional)&lt;/td&gt;
        /// &lt;th&gt;String&lt;/th&gt;
        /// &lt;td&gt;Optional user defined data for the large person
        /// group. Length should not exceed 16KB.&lt;/td&gt;
        /// &lt;/tr&gt;
        /// &lt;/tbody&gt;
        /// &lt;/table&gt;
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveNineNineacfcEightThreeaSevenbNineFourOneTwoaFourdFiveThreefThreefWithHttpMessagesAsync(string largePersonGroupId, object body = default(object), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (largePersonGroupId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "largePersonGroupId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("largePersonGroupId", largePersonGroupId);
                tracingParameters.Add("body", body);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveNineNineacfcEightThreeaSevenbNineFourOneTwoaFourdFiveThreefThreef", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "largepersongroups/{largePersonGroupId}").ToString();
            _url = _url.Replace("{largePersonGroupId}", Uri.EscapeDataString(largePersonGroupId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("PATCH");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            if(body != null)
            {
                _requestContent = SafeJsonConvert.SerializeObject(body, this.SerializationSettings);
                _httpRequest.Content = new StringContent(_requestContent, Encoding.UTF8);
                _httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
            }
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 400 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 415 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// LargePersonGroup - Delete
        /// </summary>
        /// Delete an existing large person group with specified personGroupId.
        /// Persisted data in this large person group will be deleted.
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// DELETE
        /// <param name='largePersonGroupId'>
        /// largePersonGroupId of the large person group to be deleted.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveNineNineadcTwoOneSixacSixZerofOneOnebFourEightbFiveaNinefWithHttpMessagesAsync(string largePersonGroupId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (largePersonGroupId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "largePersonGroupId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("largePersonGroupId", largePersonGroupId);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveNineNineadcTwoOneSixacSixZerofOneOnebFourEightbFiveaNinef", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "largepersongroups/{largePersonGroupId}").ToString();
            _url = _url.Replace("{largePersonGroupId}", Uri.EscapeDataString(largePersonGroupId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("DELETE");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// LargePersonGroup - List
        /// </summary>
        /// List all existing large person groups’s largePesonGroupId, name, and
        /// userData.
        /// &lt;ul&gt;
        /// &lt;li&gt;Large person groups are stored in alphabetical order of
        /// largePersonGroupId.&lt;/li&gt;
        /// &lt;li&gt;"start" parameter (string, optional) is a user-provided
        /// largePersonGroupId value that returned entries have larger ids
        /// by string comparison. "start" set to empty to indicate return from
        /// the first item.&lt;/li&gt;
        /// &lt;li&gt;"top" parameter (int, optional) specifies the number of
        /// entries to return. A maximal of 1000 entries can be returned
        /// in one call. To fetch more, you can specify "start" with the last
        /// retuned entry’s Id of the current call.&lt;/li&gt;
        /// &lt;/ul&gt;
        /// For example, total 5 large person groups: "group1", ..., "group5".
        /// &lt;br /&gt; "start=&amp;top=" will return all 5 groups.
        /// &lt;br /&gt; "start=&amp;top=2" will return "group1", "group2".
        /// &lt;br /&gt; "start=group2&amp;top=3" will return "group3", "group4",
        /// "group5".
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// GET
        /// <param name='start'>
        /// List large person groups from the least largePersonGroupId greater than
        /// the "start". It contains no more than 64 characters. Default is empty.
        /// </param>
        /// <param name='top'>
        /// The number of large person groups to list, ranging in [1, 1000]. Default
        /// is 1000.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveNineNineacfEightTwoThreeaSevenbNineFourOneTwoaFourdFiveThreefThreeeWithHttpMessagesAsync(string start = default(string), int? top = 1000, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("start", start);
                tracingParameters.Add("top", top);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveNineNineacfEightTwoThreeaSevenbNineFourOneTwoaFourdFiveThreefThreee", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "largepersongroups").ToString();
            List<string> _queryParameters = new List<string>();
            if (start != null)
            {
                _queryParameters.Add(string.Format("start={0}", Uri.EscapeDataString(start)));
            }
            if (top != null)
            {
                _queryParameters.Add(string.Format("top={0}", Uri.EscapeDataString(SafeJsonConvert.SerializeObject(top, this.SerializationSettings).Trim('"'))));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 400 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// LargePersonGroup Person - Create
        /// </summary>
        /// Create a new person in a specified large person group. To add face to this
        /// person, please call
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/599adf2a3a7b9412a4d53f42"&gt;LargePersonGroup
        /// PersonFace - Add&lt;/a&gt;.
        /// &lt;br/&gt;
        /// &lt;ul&gt;
        /// &lt;li&gt;Free-tier subscription quota:
        /// &lt;ul&gt;
        /// &lt;li&gt;1,000 persons in all large person groups.&lt;/li&gt;
        /// &lt;/ul&gt;
        /// &lt;/li&gt;
        /// &lt;li&gt;S0-tier subscription quota:
        /// &lt;ul&gt;
        /// &lt;li&gt;1,000,000 persons per large person group.&lt;/li&gt;
        /// &lt;li&gt;1,000,000 large person groups.&lt;/li&gt;
        /// &lt;li&gt;1,000,000,000 persons in all large person
        /// groups.&lt;/li&gt;
        /// &lt;/ul&gt;
        /// &lt;/li&gt;
        /// &lt;/ul&gt;
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// POST
        /// <param name='largePersonGroupId'>
        /// largePersonGroupId of the target large person group.
        /// </param>
        /// <param name='body'>
        /// JSON fields in request body:
        /// &lt;table class="element table"&gt;
        /// &lt;thead&gt;
        /// &lt;tr&gt;
        /// &lt;th&gt;Fields&lt;/th&gt;
        /// &lt;th&gt;Type&lt;/th&gt;
        /// &lt;th&gt;Description&lt;/th&gt;
        /// &lt;/tr&gt;
        /// &lt;/thead&gt;
        /// &lt;tbody&gt;
        /// &lt;tr&gt;
        /// &lt;td&gt;name&lt;/td&gt;
        /// &lt;th&gt;String&lt;/th&gt;
        /// &lt;td&gt;Name of the created person, maximum length is
        /// 128.&lt;/td&gt;
        /// &lt;/tr&gt;
        /// &lt;tr&gt;
        /// &lt;td&gt;userData (optional)&lt;/td&gt;
        /// &lt;th&gt;String&lt;/th&gt;
        /// &lt;td&gt;Optional user defined data for the person. Length
        /// should not exceed 16KB.&lt;/td&gt;
        /// &lt;/tr&gt;
        /// &lt;/tbody&gt;
        /// &lt;/table&gt;
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveNineNineadcbaThreeaSevenbNineFourOneTwoaFourdFiveThreefFourZeroWithHttpMessagesAsync(string largePersonGroupId, object body = default(object), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (largePersonGroupId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "largePersonGroupId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("largePersonGroupId", largePersonGroupId);
                tracingParameters.Add("body", body);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveNineNineadcbaThreeaSevenbNineFourOneTwoaFourdFiveThreefFourZero", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "largepersongroups/{largePersonGroupId}/persons").ToString();
            _url = _url.Replace("{largePersonGroupId}", Uri.EscapeDataString(largePersonGroupId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("POST");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            if(body != null)
            {
                _requestContent = SafeJsonConvert.SerializeObject(body, this.SerializationSettings);
                _httpRequest.Content = new StringContent(_requestContent, Encoding.UTF8);
                _httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
            }
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 400 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 415 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// LargePersonGroup Person - List
        /// </summary>
        /// List all persons’ information in the specified large person group,
        /// including personId, name, userData and persistedFaceIds
        /// of registered person faces.
        /// &lt;ul&gt;
        /// &lt;li&gt;Persons are stored in alphabetical order of personId created
        /// in
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/599adcba3a7b9412a4d53f40"&gt;LargePersonGroup
        /// Person - Create&lt;/a&gt;.&lt;/li&gt;
        /// &lt;li&gt;"start" parameter (string, optional) is a personId value
        /// that returned entries have larger ids by string comparison.
        /// "start" set to empty to indicate return from the first
        /// item.&lt;/li&gt;
        /// &lt;li&gt;"top" parameter (int, optional) specifies the number of
        /// entries to return. A maximal of 1000 entries can be returned
        /// in one call. To fetch more, you can specify "start" with the last
        /// returned entry’s personId of the current call.&lt;/li&gt;
        /// &lt;/ul&gt;
        /// For example, total 5 persons with their personId: "personId1", ...,
        /// "personId5".
        /// &lt;br /&gt; "start=&amp;top=" will return all 5 persons.
        /// &lt;br /&gt; "start=&amp;top=2" will return "personId1", "personId2".
        /// &lt;br /&gt; "start=personId2&amp;top=3" will return "personId3",
        /// "personId4", "personId5".
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// GET
        /// <param name='largePersonGroupId'>
        /// largePersonGroupId of the target large person group.
        /// </param>
        /// <param name='start'>
        /// List persons from the least personId greater than the "start". It contains
        /// no more than 64 characters. Default is empty.
        /// </param>
        /// <param name='top'>
        /// The number of persons to list, ranging in [1, 1000]. Default is 1000.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveNineNineaddaZeroSixacSixZerofOneOnebFourEightbFiveaaOneWithHttpMessagesAsync(string largePersonGroupId, string start = default(string), int? top = 1000, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (largePersonGroupId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "largePersonGroupId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("largePersonGroupId", largePersonGroupId);
                tracingParameters.Add("start", start);
                tracingParameters.Add("top", top);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveNineNineaddaZeroSixacSixZerofOneOnebFourEightbFiveaaOne", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "largepersongroups/{largePersonGroupId}/persons").ToString();
            _url = _url.Replace("{largePersonGroupId}", Uri.EscapeDataString(largePersonGroupId));
            List<string> _queryParameters = new List<string>();
            if (start != null)
            {
                _queryParameters.Add(string.Format("start={0}", Uri.EscapeDataString(start)));
            }
            if (top != null)
            {
                _queryParameters.Add(string.Format("top={0}", Uri.EscapeDataString(SafeJsonConvert.SerializeObject(top, this.SerializationSettings).Trim('"'))));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// LargePersonGroup Person - Get
        /// </summary>
        /// Retrieve a person's name and userData, and the persisted faceIds
        /// representing the registered person face image.
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// GET
        /// <param name='largePersonGroupId'>
        /// largePersonGroupId of the target large person group.
        /// </param>
        /// <param name='personId'>
        /// personId of the target person.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveNineNineaddThreeSevenSixacSixZerofOneOnebFourEightbFiveaaZeroWithHttpMessagesAsync(string largePersonGroupId, string personId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (largePersonGroupId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "largePersonGroupId");
            }
            if (personId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "personId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("largePersonGroupId", largePersonGroupId);
                tracingParameters.Add("personId", personId);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveNineNineaddThreeSevenSixacSixZerofOneOnebFourEightbFiveaaZero", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "largepersongroups/{largePersonGroupId}/persons/{personId}").ToString();
            _url = _url.Replace("{largePersonGroupId}", Uri.EscapeDataString(largePersonGroupId));
            _url = _url.Replace("{personId}", Uri.EscapeDataString(personId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// LargePersonGroup Person - Update
        /// </summary>
        /// Update name or userData of a person.
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// PATCH
        /// <param name='largePersonGroupId'>
        /// largePersonGroupId of the target large person group.
        /// </param>
        /// <param name='personId'>
        /// personId of the target person.
        /// </param>
        /// <param name='body'>
        /// JSON fields in request body:
        /// &lt;table class="element table"&gt;
        /// &lt;thead&gt;
        /// &lt;tr&gt;
        /// &lt;th&gt;Fields&lt;/th&gt;
        /// &lt;th&gt;Type&lt;/th&gt;
        /// &lt;th&gt;Description&lt;/th&gt;
        /// &lt;/tr&gt;
        /// &lt;/thead&gt;
        /// &lt;tbody&gt;
        /// &lt;tr&gt;
        /// &lt;td&gt;name&lt;/td&gt;
        /// &lt;th&gt;String&lt;/th&gt;
        /// &lt;td&gt;Name of the created person, maximum length is
        /// 128.&lt;/td&gt;
        /// &lt;/tr&gt;
        /// &lt;tr&gt;
        /// &lt;td&gt;userData (optional)&lt;/td&gt;
        /// &lt;th&gt;String&lt;/th&gt;
        /// &lt;td&gt;Optional user defined data for the person. Length
        /// should not exceed 16KB.&lt;/td&gt;
        /// &lt;/tr&gt;
        /// &lt;/tbody&gt;
        /// &lt;/table&gt;
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveNineNineadeZeroFourThreeaSevenbNineFourOneTwoaFourdFiveThreefFourOneWithHttpMessagesAsync(string largePersonGroupId, string personId, object body = default(object), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (largePersonGroupId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "largePersonGroupId");
            }
            if (personId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "personId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("largePersonGroupId", largePersonGroupId);
                tracingParameters.Add("personId", personId);
                tracingParameters.Add("body", body);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveNineNineadeZeroFourThreeaSevenbNineFourOneTwoaFourdFiveThreefFourOne", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "largepersongroups/{largePersonGroupId}/persons/{personId}").ToString();
            _url = _url.Replace("{largePersonGroupId}", Uri.EscapeDataString(largePersonGroupId));
            _url = _url.Replace("{personId}", Uri.EscapeDataString(personId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("PATCH");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            if(body != null)
            {
                _requestContent = SafeJsonConvert.SerializeObject(body, this.SerializationSettings);
                _httpRequest.Content = new StringContent(_requestContent, Encoding.UTF8);
                _httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
            }
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 400 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 415 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// LargePersonGroup Person - Delete
        /// </summary>
        /// Delete an existing person from a large person group. All stored person
        /// data, and face images in the person entry will be deleted.
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// DELETE
        /// <param name='largePersonGroupId'>
        /// largePersonGroupId of the target large person group.
        /// </param>
        /// <param name='personId'>
        /// personId of the target person.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveNineNineadeFivecSixacSixZerofOneOnebFourEightbFiveaaTwoWithHttpMessagesAsync(string largePersonGroupId, string personId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (largePersonGroupId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "largePersonGroupId");
            }
            if (personId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "personId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("largePersonGroupId", largePersonGroupId);
                tracingParameters.Add("personId", personId);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveNineNineadeFivecSixacSixZerofOneOnebFourEightbFiveaaTwo", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "largepersongroups/{largePersonGroupId}/persons/{personId}").ToString();
            _url = _url.Replace("{largePersonGroupId}", Uri.EscapeDataString(largePersonGroupId));
            _url = _url.Replace("{personId}", Uri.EscapeDataString(personId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("DELETE");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// LargePersonGroup Person - Add Face
        /// </summary>
        /// Add a face image to a person into a large person group for face
        /// identification or verification. To deal with the image of
        /// multiple faces, input face can be specified as an image with a targetFace
        /// rectangle. It returns a persistedFaceId representing
        /// the added face. The face image and related info will be stored on server
        /// until
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/599ae2966ac60f11b48b5aa3"&gt;LargePersonGroup
        /// PersonFace - Delete&lt;/a&gt;,
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/599ade5c6ac60f11b48b5aa2"&gt;LargePersonGroup
        /// Person - Delete&lt;/a&gt; or
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/599adc216ac60f11b48b5a9f"&gt;LargePersonGroup
        /// - Delete&lt;/a&gt; is called.
        /// &lt;br /&gt; Note persistedFaceId is different from faceId generated by
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236"&gt;Face
        /// - Detect&lt;/a&gt;.
        /// &lt;ul&gt;
        /// &lt;li&gt;Higher face image quality means better recognition
        /// precision. Please consider high-quality faces: frontal, clear, and
        /// face size is 200x200 pixels (100 pixels between eyes) or
        /// bigger.&lt;/li&gt;
        /// &lt;li&gt;Each person entry can hold up to 248 faces.&lt;/li&gt;
        /// &lt;li&gt;JPEG, PNG, GIF (the first frame), and BMP format are
        /// supported. The allowed image file size is from 1KB to 4MB.&lt;/li&gt;
        /// &lt;li&gt;"targetFace" rectangle should contain one face. Zero or
        /// multiple faces will be regarded as an error. If the provided
        /// "targetFace" rectangle is not returned from
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236"&gt;Face
        /// - Detect&lt;/a&gt;, there’s no guarantee to detect and add the face
        /// successfully.&lt;/li&gt;
        /// &lt;li&gt;Out of detectable face size (36x36 - 4096x4096 pixels),
        /// large head-pose, or large occlusions will cause failures.&lt;/li&gt;
        /// &lt;li&gt;Adding/deleting faces to/from a same person will be
        /// processed sequentially. Adding/deleting faces to/from different persons
        /// are processed in parallel.&lt;/li&gt;
        /// &lt;/ul&gt;
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// POST
        /// <param name='largePersonGroupId'>
        /// largePersonGroupId of the target large person group.
        /// </param>
        /// <param name='personId'>
        /// personId of the target person.
        /// </param>
        /// <param name='userData'>
        /// User-specified data about the target face to add for any purpose. The
        /// maximum length is 1KB.
        /// </param>
        /// <param name='targetFace'>
        /// A face rectangle to specify the target face to be added to a person, in
        /// the format of "targetFace=left,top,width,height". E.g.
        /// "targetFace=10,10,100,100". If there is more than one face in the image,
        /// targetFace is required to specify which face to add. No targetFace means
        /// there is only one face detected in the entire image.
        /// </param>
        /// <param name='body'>
        /// &lt;br/&gt;
        /// &lt;br/&gt; JSON fields in request body:
        /// &lt;table class="element table"&gt;
        /// &lt;thead&gt;
        /// &lt;tr&gt;
        /// &lt;th&gt;Fields&lt;/th&gt;
        /// &lt;th&gt;Type&lt;/th&gt;
        /// &lt;th&gt;Description&lt;/th&gt;
        /// &lt;/tr&gt;
        /// &lt;/thead&gt;
        /// &lt;tbody&gt;
        /// &lt;tr&gt;
        /// &lt;td&gt;url&lt;/td&gt;
        /// &lt;th&gt;String&lt;/th&gt;
        /// &lt;td&gt;Face image URL. Valid image size is from 1KB to 4MB.
        /// Only one face is allowed per image.&lt;/td&gt;
        /// &lt;/tr&gt;
        /// &lt;/tbody&gt;
        /// &lt;/table&gt;
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveNineNineadfTwoaThreeaSevenbNineFourOneTwoaFourdFiveThreefFourTwoWithHttpMessagesAsync(string largePersonGroupId, string personId, string userData = default(string), string targetFace = default(string), object body = default(object), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (largePersonGroupId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "largePersonGroupId");
            }
            if (personId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "personId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("largePersonGroupId", largePersonGroupId);
                tracingParameters.Add("personId", personId);
                tracingParameters.Add("userData", userData);
                tracingParameters.Add("targetFace", targetFace);
                tracingParameters.Add("body", body);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveNineNineadfTwoaThreeaSevenbNineFourOneTwoaFourdFiveThreefFourTwo", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces").ToString();
            _url = _url.Replace("{largePersonGroupId}", Uri.EscapeDataString(largePersonGroupId));
            _url = _url.Replace("{personId}", Uri.EscapeDataString(personId));
            List<string> _queryParameters = new List<string>();
            if (userData != null)
            {
                _queryParameters.Add(string.Format("userData={0}", Uri.EscapeDataString(userData)));
            }
            if (targetFace != null)
            {
                _queryParameters.Add(string.Format("targetFace={0}", Uri.EscapeDataString(targetFace)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("POST");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            if(body != null)
            {
                _requestContent = SafeJsonConvert.SerializeObject(body, this.SerializationSettings);
                _httpRequest.Content = new StringContent(_requestContent, Encoding.UTF8);
                _httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
            }
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 400 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 408 && (int)_statusCode != 409 && (int)_statusCode != 415 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// LargePersonGroup Person - Get Face
        /// </summary>
        /// Retrieve person face information. The persisted person face is specified
        /// by its largePersonGroupId, personId and persistedFaceId.
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// GET
        /// <param name='largePersonGroupId'>
        /// largePersonGroupId of the target large person group.
        /// </param>
        /// <param name='personId'>
        /// personId of the target person.
        /// </param>
        /// <param name='persistedFaceId'>
        /// persistedFaceId of the target persisted face.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveNineNineaeOnebSixThreeaSevenbNineFourOneTwoaFourdFiveThreefFourThreeWithHttpMessagesAsync(string largePersonGroupId, string personId, string persistedFaceId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (largePersonGroupId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "largePersonGroupId");
            }
            if (personId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "personId");
            }
            if (persistedFaceId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "persistedFaceId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("largePersonGroupId", largePersonGroupId);
                tracingParameters.Add("personId", personId);
                tracingParameters.Add("persistedFaceId", persistedFaceId);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveNineNineaeOnebSixThreeaSevenbNineFourOneTwoaFourdFiveThreefFourThree", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}").ToString();
            _url = _url.Replace("{largePersonGroupId}", Uri.EscapeDataString(largePersonGroupId));
            _url = _url.Replace("{personId}", Uri.EscapeDataString(personId));
            _url = _url.Replace("{persistedFaceId}", Uri.EscapeDataString(persistedFaceId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// LargePersonGroup Person - Update Face
        /// </summary>
        /// Update a person persisted face's userData field.
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// PATCH
        /// <param name='largePersonGroupId'>
        /// largePersonGroupId of the target large person group.
        /// </param>
        /// <param name='personId'>
        /// personId of the target person.
        /// </param>
        /// <param name='persistedFaceId'>
        /// persistedFaceId of the target persisted face.
        /// </param>
        /// <param name='body'>
        /// JSON fields in request body:
        /// &lt;table class="element table"&gt;
        /// &lt;thead&gt;
        /// &lt;tr&gt;
        /// &lt;th&gt;Fields&lt;/th&gt;
        /// &lt;th&gt;Type&lt;/th&gt;
        /// &lt;th&gt;Description&lt;/th&gt;
        /// &lt;/tr&gt;
        /// &lt;/thead&gt;
        /// &lt;tbody&gt;
        /// &lt;tr&gt;
        /// &lt;td&gt;userData&lt;/td&gt;
        /// &lt;th&gt;String&lt;/th&gt;
        /// &lt;td&gt;Attach userData to person's persisted face. The size
        /// limit is 1KB.&lt;/td&gt;
        /// &lt;/tr&gt;
        /// &lt;/tbody&gt;
        /// &lt;/table&gt;
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveNineNineaeTwoZeroOneThreeaSevenbNineFourOneTwoaFourdFiveThreefFourFourWithHttpMessagesAsync(string largePersonGroupId, string personId, string persistedFaceId, object body = default(object), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (largePersonGroupId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "largePersonGroupId");
            }
            if (personId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "personId");
            }
            if (persistedFaceId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "persistedFaceId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("largePersonGroupId", largePersonGroupId);
                tracingParameters.Add("personId", personId);
                tracingParameters.Add("persistedFaceId", persistedFaceId);
                tracingParameters.Add("body", body);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveNineNineaeTwoZeroOneThreeaSevenbNineFourOneTwoaFourdFiveThreefFourFour", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}").ToString();
            _url = _url.Replace("{largePersonGroupId}", Uri.EscapeDataString(largePersonGroupId));
            _url = _url.Replace("{personId}", Uri.EscapeDataString(personId));
            _url = _url.Replace("{persistedFaceId}", Uri.EscapeDataString(persistedFaceId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("PATCH");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            if(body != null)
            {
                _requestContent = SafeJsonConvert.SerializeObject(body, this.SerializationSettings);
                _httpRequest.Content = new StringContent(_requestContent, Encoding.UTF8);
                _httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
            }
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 400 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 415 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// LargePersonGroup Person - Delete Face
        /// </summary>
        /// Delete a face from a person in a large person group. Face data and image
        /// related to this face entry will be also deleted.
        /// &lt;br /&gt; Adding/deleting faces to/from a same person will be processed
        /// sequentially. Adding/deleting faces to/from different persons are
        /// processed
        /// in parallel.
        /// &lt;br /&gt;
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// DELETE
        /// <param name='largePersonGroupId'>
        /// largePersonGroupId of the target large person group.
        /// </param>
        /// <param name='personId'>
        /// personId of the target person.
        /// </param>
        /// <param name='persistedFaceId'>
        /// persistedFaceId of the target persisted face.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveNineNineaeTwoNineSixSixacSixZerofOneOnebFourEightbFiveaaThreeWithHttpMessagesAsync(string largePersonGroupId, string personId, string persistedFaceId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (largePersonGroupId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "largePersonGroupId");
            }
            if (personId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "personId");
            }
            if (persistedFaceId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "persistedFaceId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("largePersonGroupId", largePersonGroupId);
                tracingParameters.Add("personId", personId);
                tracingParameters.Add("persistedFaceId", persistedFaceId);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveNineNineaeTwoNineSixSixacSixZerofOneOnebFourEightbFiveaaThree", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}").ToString();
            _url = _url.Replace("{largePersonGroupId}", Uri.EscapeDataString(largePersonGroupId));
            _url = _url.Replace("{personId}", Uri.EscapeDataString(personId));
            _url = _url.Replace("{persistedFaceId}", Uri.EscapeDataString(persistedFaceId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("DELETE");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 409 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// LargePersonGroup - Train
        /// </summary>
        /// Submit a large person group training task. Training is a crucial step that
        /// only a trained large person group can be used
        /// by
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239"&gt;Face
        /// - Identify&lt;/a&gt;.
        /// &lt;br /&gt;
        /// &lt;br /&gt; The training task is an asynchronous task. Training time
        /// depends on the number of person entries, and their faces in a large
        /// person group. It could be in several seconds, or up to half a hour for
        /// 1,000,000 persons. To check training completion, please
        /// use
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/599ae32c6ac60f11b48b5aa5"&gt;LargePersonGroup
        /// - Get Training Status&lt;/a&gt;.
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// POST
        /// <param name='largePersonGroupId'>
        /// Target large person group to be trained.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveNineNineaeTwodOneSixacSixZerofOneOnebFourEightbFiveaaFourWithHttpMessagesAsync(string largePersonGroupId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (largePersonGroupId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "largePersonGroupId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("largePersonGroupId", largePersonGroupId);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveNineNineaeTwodOneSixacSixZerofOneOnebFourEightbFiveaaFour", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "largepersongroups/{largePersonGroupId}/train").ToString();
            _url = _url.Replace("{largePersonGroupId}", Uri.EscapeDataString(largePersonGroupId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("POST");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 202 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 409 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// LargePersonGroup - Get Training Status
        /// </summary>
        /// To check large person group training status completed or still ongoing.
        /// LargePersonGroup Training is an asynchronous operation
        /// triggered by
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/599ae2d16ac60f11b48b5aa4"&gt;LargePersonGroup
        /// - Train&lt;/a&gt; API.
        /// &lt;br /&gt; Training time depends on the number of person entries, and
        /// their faces in a large person group. It could be in seconds,
        /// or up to half an hour for 1,000,000 persons.
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// GET
        /// <param name='largePersonGroupId'>
        /// LargePersonGroupId of target person group.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveNineNineaeThreeTwocSixacSixZerofOneOnebFourEightbFiveaaFiveWithHttpMessagesAsync(string largePersonGroupId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (largePersonGroupId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "largePersonGroupId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("largePersonGroupId", largePersonGroupId);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveNineNineaeThreeTwocSixacSixZerofOneOnebFourEightbFiveaaFive", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "largepersongroups/{largePersonGroupId}/training").ToString();
            _url = _url.Replace("{largePersonGroupId}", Uri.EscapeDataString(largePersonGroupId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 409 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// LargeFaceList - Create
        /// </summary>
        /// Create an empty large face list with user-specified largeFaceListId, name
        /// and an optional userData.
        /// &lt;br /&gt; Large face list is a list of faces, up to 1,000,000 faces,
        /// and used by
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237"&gt;Face
        /// - Find Similar&lt;/a&gt;.
        /// &lt;br /&gt; After creation, user should use
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/5a158c10d2de3616c086f2d3"&gt;LargeFaceList
        /// Face - Add&lt;/a&gt; to import the faces and
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/5a158422d2de3616c086f2d1"&gt;LargeFaceList
        /// - Train&lt;/a&gt; to make it ready for
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237"&gt;Face
        /// - Find Similar&lt;/a&gt;. Faces are stored on server until
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/5a1580d5d2de3616c086f2cd"&gt;LargeFaceList
        /// - Delete&lt;/a&gt; is called.
        /// &lt;br /&gt; Find Similar is used for scenario like finding celebrity-like
        /// faces, similar face filtering, or as a light way face identification.
        /// But if the actual use is to identify person, please use
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395244"&gt;PersonGroup&lt;/a&gt;
        /// /
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/599acdee6ac60f11b48b5a9d"&gt;LargePersonGroup&lt;/a&gt;
        /// and
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395239"&gt;Face
        /// - Identify&lt;/a&gt;.
        /// &lt;br /&gt;
        /// &lt;ul&gt;
        /// &lt;li&gt;Free-tier subscription quota: 64 large face
        /// lists.&lt;/li&gt;
        /// &lt;li&gt;S0-tier subscription quota: 1,000,000 large face
        /// lists.&lt;/li&gt;
        /// &lt;/ul&gt;
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// PUT
        /// <param name='largeFaceListId'>
        /// Valid character is letter in lower case or digit or '-' or '_', maximum
        /// length is 64.
        /// </param>
        /// <param name='body'>
        /// JSON fields in request body:
        /// &lt;table class="element table"&gt;
        /// &lt;thead&gt;
        /// &lt;tr&gt;
        /// &lt;th&gt;Fields&lt;/th&gt;
        /// &lt;th&gt;Type&lt;/th&gt;
        /// &lt;th&gt;Description&lt;/th&gt;
        /// &lt;/tr&gt;
        /// &lt;/thead&gt;
        /// &lt;tbody&gt;
        /// &lt;tr&gt;
        /// &lt;td&gt;name&lt;/td&gt;
        /// &lt;th&gt;String&lt;/th&gt;
        /// &lt;td&gt;Name of the created large face list, maximum length
        /// is 128.&lt;/td&gt;
        /// &lt;/tr&gt;
        /// &lt;tr&gt;
        /// &lt;td&gt;userData (optional)&lt;/td&gt;
        /// &lt;th&gt;String&lt;/th&gt;
        /// &lt;td&gt;Optional user defined data for the large face list.
        /// Length should not exceed 16KB.&lt;/td&gt;
        /// &lt;/tr&gt;
        /// &lt;/tbody&gt;
        /// &lt;/table&gt;
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveaOneFiveSevenbSixEightdTwodeThreeSixOneSixcZeroEightSixfTwoccWithHttpMessagesAsync(string largeFaceListId, object body = default(object), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (largeFaceListId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "largeFaceListId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("largeFaceListId", largeFaceListId);
                tracingParameters.Add("body", body);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveaOneFiveSevenbSixEightdTwodeThreeSixOneSixcZeroEightSixfTwocc", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "largefacelists/{largeFaceListId}").ToString();
            _url = _url.Replace("{largeFaceListId}", Uri.EscapeDataString(largeFaceListId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("PUT");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            if(body != null)
            {
                _requestContent = SafeJsonConvert.SerializeObject(body, this.SerializationSettings);
                _httpRequest.Content = new StringContent(_requestContent, Encoding.UTF8);
                _httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
            }
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 400 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 409 && (int)_statusCode != 415 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// LargeFaceList - Delete
        /// </summary>
        /// Delete a specified large face list. The related face images in the large
        /// face list will be deleted, too.
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// DELETE
        /// <param name='largeFaceListId'>
        /// Valid character is letter in lower case or digit or '-' or '_', maximum
        /// length is 64.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveaOneFiveEightZerodFivedTwodeThreeSixOneSixcZeroEightSixfTwocdWithHttpMessagesAsync(string largeFaceListId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (largeFaceListId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "largeFaceListId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("largeFaceListId", largeFaceListId);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveaOneFiveEightZerodFivedTwodeThreeSixOneSixcZeroEightSixfTwocd", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "largefacelists/{largeFaceListId}").ToString();
            _url = _url.Replace("{largeFaceListId}", Uri.EscapeDataString(largeFaceListId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("DELETE");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// LargeFaceList - Get
        /// </summary>
        /// Retrieve a large face list’s largeFaceListId, name, userData.
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// GET
        /// <param name='largeFaceListId'>
        /// largeFaceListId of the target large face list.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveaOneFiveEightTwoSevencdTwodeThreeSixOneSixcZeroEightSixfTwoceWithHttpMessagesAsync(string largeFaceListId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (largeFaceListId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "largeFaceListId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("largeFaceListId", largeFaceListId);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveaOneFiveEightTwoSevencdTwodeThreeSixOneSixcZeroEightSixfTwoce", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "largefacelists/{largeFaceListId}").ToString();
            _url = _url.Replace("{largeFaceListId}", Uri.EscapeDataString(largeFaceListId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// LargeFaceList - Update
        /// </summary>
        /// Update information of a large face list, including name and userData.
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// PATCH
        /// <param name='largeFaceListId'>
        /// Valid character is letter in lower case or digit or '-' or '_', maximum
        /// length is 64.
        /// </param>
        /// <param name='body'>
        /// JSON fields in request body:
        /// &lt;table class="element table"&gt;
        /// &lt;thead&gt;
        /// &lt;tr&gt;
        /// &lt;th&gt;Fields&lt;/th&gt;
        /// &lt;th&gt;Type&lt;/th&gt;
        /// &lt;th&gt;Description&lt;/th&gt;
        /// &lt;/tr&gt;
        /// &lt;/thead&gt;
        /// &lt;tbody&gt;
        /// &lt;tr&gt;
        /// &lt;td&gt;name&lt;/td&gt;
        /// &lt;th&gt;String&lt;/th&gt;
        /// &lt;td&gt;Name of the large face list, maximum length is
        /// 128&lt;/td&gt;
        /// &lt;/tr&gt;
        /// &lt;tr&gt;
        /// &lt;td&gt;userData (optional)&lt;/td&gt;
        /// &lt;th&gt;String&lt;/th&gt;
        /// &lt;td&gt;Optional user defined data for the large face list.
        /// Length should not exceed 16KB&lt;/td&gt;
        /// &lt;/tr&gt;
        /// &lt;/tbody&gt;
        /// &lt;/table&gt;
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveaOneFiveEightFourNineNinedTwodeThreeSixOneSixcZeroEightSixfTwodTwoWithHttpMessagesAsync(string largeFaceListId, object body = default(object), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (largeFaceListId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "largeFaceListId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("largeFaceListId", largeFaceListId);
                tracingParameters.Add("body", body);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveaOneFiveEightFourNineNinedTwodeThreeSixOneSixcZeroEightSixfTwodTwo", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "largefacelists/{largeFaceListId}").ToString();
            _url = _url.Replace("{largeFaceListId}", Uri.EscapeDataString(largeFaceListId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("PATCH");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            if(body != null)
            {
                _requestContent = SafeJsonConvert.SerializeObject(body, this.SerializationSettings);
                _httpRequest.Content = new StringContent(_requestContent, Encoding.UTF8);
                _httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
            }
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 400 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 415 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// LargeFaceList - Get Training Status
        /// </summary>
        /// To check the large face list training status completed or still ongoing.
        /// LargeFaceList Training is an asynchronous operation
        /// triggered by
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/5a158422d2de3616c086f2d1"&gt;LargeFaceList
        /// - Train&lt;/a&gt; API.
        /// &lt;br /&gt; Training time depends on the number of face entries in a
        /// large face list. It could be in seconds, or up to half an hour
        /// for 1,000,000 faces.
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// GET
        /// <param name='largeFaceListId'>
        /// largeFaceListId of the target large face list.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveaOneFiveEightTwofEightdTwodeThreeSixOneSixcZeroEightSixfTwocfWithHttpMessagesAsync(string largeFaceListId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (largeFaceListId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "largeFaceListId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("largeFaceListId", largeFaceListId);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveaOneFiveEightTwofEightdTwodeThreeSixOneSixcZeroEightSixfTwocf", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "largefacelists/{largeFaceListId}/training").ToString();
            _url = _url.Replace("{largeFaceListId}", Uri.EscapeDataString(largeFaceListId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// LargeFaceList - List
        /// </summary>
        /// List large face lists’ information of largeFaceListId, name and userData.
        /// &lt;br /&gt; To get face information inside largeFaceList use
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/5a158cf2d2de3616c086f2d5"&gt;LargeFaceList
        /// Face - Get&lt;/a&gt;.
        /// &lt;ul&gt;
        /// &lt;li&gt;Large face lists are stored in alphabetical order of
        /// largeFaceListId.&lt;/li&gt;
        /// &lt;li&gt;"start" parameter (string, optional) is a user-provided
        /// largeFaceListId value that returned entries have larger ids
        /// by string comparison. "start" set to empty to indicate return from
        /// the first item.&lt;/li&gt;
        /// &lt;li&gt;"top" parameter (int, optional) specifies the number of
        /// entries to return. A maximal of 1000 entries can be returned
        /// in one call. To fetch more, you can specify "start" with the last
        /// retuned entry’s Id of the current call.&lt;/li&gt;
        /// &lt;/ul&gt;
        /// For example, total 5 large person lists: "list1", ..., "list5".
        /// &lt;br /&gt; "start=&amp;top=" will return all 5 lists.
        /// &lt;br /&gt; "start=&amp;top=2" will return "list1", "list2".
        /// &lt;br /&gt; "start=list2&amp;top=3" will return "list3", "list4",
        /// "list5".
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// GET
        /// <param name='start'>
        /// List large face lists from the least largeFaceListId greater than the
        /// "start". It contains no more than 64 characters. Default is empty.
        /// </param>
        /// <param name='top'>
        /// The number of large face lists to list, ranging in [1, 1000]. Default is
        /// 1000. Possible values include: '1000'
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveaOneFiveEightThreeEightSevendTwodeThreeSixOneSixcZeroEightSixfTwodZeroWithHttpMessagesAsync(string start = default(string), string top = "1000", Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("start", start);
                tracingParameters.Add("top", top);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveaOneFiveEightThreeEightSevendTwodeThreeSixOneSixcZeroEightSixfTwodZero", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "largefacelists").ToString();
            List<string> _queryParameters = new List<string>();
            if (start != null)
            {
                _queryParameters.Add(string.Format("start={0}", Uri.EscapeDataString(start)));
            }
            if (top != null)
            {
                _queryParameters.Add(string.Format("top={0}", Uri.EscapeDataString(top)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 400 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// LargeFaceList - Train
        /// </summary>
        /// Submit a large face list training task. Training is a crucial step that
        /// only a trained large face list can be used by
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395237"&gt;Face
        /// - Find Similar&lt;/a&gt;.
        /// &lt;br /&gt;
        /// &lt;br /&gt; The training task is an asynchronous task. Training time
        /// depends on the number of face entries in a large face list. It could
        /// be in seconds, or up to half an hour for 1,000,000 faces. To check
        /// training completion, please use
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/5a1582f8d2de3616c086f2cf"&gt;LargeFaceList
        /// - Get Training Status&lt;/a&gt;.
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// POST
        /// <param name='largeFaceListId'>
        /// largeFaceListId of the target large face list to be trained.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveaOneFiveEightFourTwoTwodTwodeThreeSixOneSixcZeroEightSixfTwodOneWithHttpMessagesAsync(string largeFaceListId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (largeFaceListId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "largeFaceListId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("largeFaceListId", largeFaceListId);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveaOneFiveEightFourTwoTwodTwodeThreeSixOneSixcZeroEightSixfTwodOne", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "largefacelists/{largeFaceListId}/train").ToString();
            _url = _url.Replace("{largeFaceListId}", Uri.EscapeDataString(largeFaceListId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("POST");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 202 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 409 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// LargeFaceList - Add Face
        /// </summary>
        /// Add a face to a specified large face list, up to 1,000,000 faces.
        /// &lt;br /&gt; To deal with the image of multiple faces, input face can be
        /// specified as an image with a targetFace rectangle. It returns
        /// a persistedFaceId representing the added face. The face image and related
        /// info will be stored on server until
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/5a158c8ad2de3616c086f2d4"&gt;LargeFaceList
        /// Face - Delete&lt;/a&gt; or
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/5a1580d5d2de3616c086f2cd"&gt;LargeFaceList
        /// - Delete&lt;/a&gt; is called.
        /// &lt;br /&gt; Note persistedFaceId is different from faceId generated by
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236"&gt;Face
        /// - Detect&lt;/a&gt;.
        /// &lt;ul&gt;
        /// &lt;li&gt;JPEG, PNG, GIF (the first frame), and BMP format are
        /// supported. The allowed image file size is from 1KB to 4MB.&lt;/li&gt;
        /// &lt;li&gt;"targetFace" rectangle should contain one face. Zero or
        /// multiple faces will be regarded as an error. If the provided
        /// "targetFace" rectangle is not returned from
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236"&gt;Face
        /// - Detect&lt;/a&gt;, there’s no guarantee to detect and add the face
        /// successfully.&lt;/li&gt;
        /// &lt;li&gt;Out of detectable face size (36x36 - 4096x4096 pixels),
        /// large head-pose, or large occlusions will cause failures.&lt;/li&gt;
        /// &lt;li&gt;Adding/deleting faces to/from a same face list are processed
        /// sequentially and to/from different face lists are in parallel.&lt;/li&gt;
        /// &lt;/ul&gt;
        /// Quota:
        /// &lt;ul&gt;
        /// &lt;li&gt;Free-tier subscription quota: 1,000 faces per large face
        /// list.&lt;/li&gt;
        /// &lt;li&gt;S0-tier subscription quota: 1,000,000 faces per large face
        /// list.&lt;/li&gt;
        /// &lt;/ul&gt;
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// POST
        /// <param name='largeFaceListId'>
        /// Valid character is letter in lower case or digit or '-' or '_', maximum
        /// length is 64.
        /// </param>
        /// <param name='userData'>
        /// User-specified data about the target face to add for any purpose. The
        /// maximum length is 1KB.
        /// </param>
        /// <param name='targetFace'>
        /// A face rectangle to specify the target face to be added to a large face
        /// list, in the format of "targetFace=left,top,width,height". E.g.
        /// "targetFace=10,10,100,100". If there is more than one face in the image,
        /// targetFace is required to specify which face to add. No targetFace means
        /// there is only one face detected in the entire image.
        /// </param>
        /// <param name='body'>
        /// &lt;br/&gt;
        /// &lt;br/&gt; JSON fields in request body:
        /// &lt;table class="element table"&gt;
        /// &lt;thead&gt;
        /// &lt;tr&gt;
        /// &lt;th&gt;Fields&lt;/th&gt;
        /// &lt;th&gt;Type&lt;/th&gt;
        /// &lt;th&gt;Description&lt;/th&gt;
        /// &lt;/tr&gt;
        /// &lt;/thead&gt;
        /// &lt;tbody&gt;
        /// &lt;tr&gt;
        /// &lt;td&gt;url&lt;/td&gt;
        /// &lt;th&gt;String&lt;/th&gt;
        /// &lt;td&gt;Face image URL. Valid image size is from 1KB to 4MB.
        /// Only one face is allowed per image.&lt;/td&gt;
        /// &lt;/tr&gt;
        /// &lt;/tbody&gt;
        /// &lt;/table&gt;
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveaOneFiveEightcOneZerodTwodeThreeSixOneSixcZeroEightSixfTwodThreeWithHttpMessagesAsync(string largeFaceListId, string userData = default(string), string targetFace = default(string), object body = default(object), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (largeFaceListId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "largeFaceListId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("largeFaceListId", largeFaceListId);
                tracingParameters.Add("userData", userData);
                tracingParameters.Add("targetFace", targetFace);
                tracingParameters.Add("body", body);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveaOneFiveEightcOneZerodTwodeThreeSixOneSixcZeroEightSixfTwodThree", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "largefacelists/{largeFaceListId}/persistedfaces").ToString();
            _url = _url.Replace("{largeFaceListId}", Uri.EscapeDataString(largeFaceListId));
            List<string> _queryParameters = new List<string>();
            if (userData != null)
            {
                _queryParameters.Add(string.Format("userData={0}", Uri.EscapeDataString(userData)));
            }
            if (targetFace != null)
            {
                _queryParameters.Add(string.Format("targetFace={0}", Uri.EscapeDataString(targetFace)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("POST");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            if(body != null)
            {
                _requestContent = SafeJsonConvert.SerializeObject(body, this.SerializationSettings);
                _httpRequest.Content = new StringContent(_requestContent, Encoding.UTF8);
                _httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
            }
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 400 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 408 && (int)_statusCode != 415 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// LargeFaceList - List Face
        /// </summary>
        /// List faces' persistedFaceId and userData in a specified large face list.
        /// &lt;ul&gt;
        /// &lt;li&gt;Faces are stored in alphabetical order of persistedFaceId
        /// created in
        /// &lt;a
        /// href="/docs/services/563879b61984550e40cbbe8d/operations/5a158c10d2de3616c086f2d3"&gt;LargeFaceList
        /// Face - Add&lt;/a&gt;.&lt;/li&gt;
        /// &lt;li&gt;"start" parameter (string, optional) is a persistedFaceId
        /// value that returned entries have larger ids by string comparison.
        /// "start" set to empty to indicate return from the first
        /// item.&lt;/li&gt;
        /// &lt;li&gt;"top" parameter (int, optional) specifies the number of
        /// entries to return. A maximal of 1000 entries can be returned
        /// in one call. To fetch more, you can specify "start" with the last
        /// returned entry’s persistedFaceId of the current call.&lt;/li&gt;
        /// &lt;/ul&gt;
        /// For example, total 5 persons with their face: "face1", ..., "face5".
        /// &lt;br /&gt; "start=&amp;top=" will return all 5 persons.
        /// &lt;br /&gt; "start=&amp;top=2" will return "face1", "face2".
        /// &lt;br /&gt; "start=face2&amp;top=3" will return "face3", "face4",
        /// "face5".
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// GET
        /// <param name='largeFaceListId'>
        /// Valid character is letter in lower case or digit or '-' or '_', maximum
        /// length is 64.
        /// </param>
        /// <param name='start'>
        /// List large face list faces from the least persistedFaceId greater than the
        /// "start". It contains no more than 64 characters. Default is empty.
        /// </param>
        /// <param name='top'>
        /// The number of large face list faces to list, ranging in [1, 1000]. Default
        /// is 1000. Possible values include: '1000'
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveaOneFiveEightdbFourdTwodeThreeSixOneSixcZeroEightSixfTwodSixWithHttpMessagesAsync(string largeFaceListId, string start = default(string), string top = "1000", Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (largeFaceListId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "largeFaceListId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("largeFaceListId", largeFaceListId);
                tracingParameters.Add("start", start);
                tracingParameters.Add("top", top);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveaOneFiveEightdbFourdTwodeThreeSixOneSixcZeroEightSixfTwodSix", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "largefacelists/{largeFaceListId}/persistedfaces").ToString();
            _url = _url.Replace("{largeFaceListId}", Uri.EscapeDataString(largeFaceListId));
            List<string> _queryParameters = new List<string>();
            if (start != null)
            {
                _queryParameters.Add(string.Format("start={0}", Uri.EscapeDataString(start)));
            }
            if (top != null)
            {
                _queryParameters.Add(string.Format("top={0}", Uri.EscapeDataString(top)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 400 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// LargeFaceList - Delete Face
        /// </summary>
        /// Delete a face from a large face list by specified largeFaceListId and
        /// persisitedFaceId. The related face image will be deleted, too.
        /// &lt;br /&gt;
        /// Adding/deleting faces to/from a same large face list are processed
        /// sequentially and to/from different large face lists are in parallel.
        /// &lt;h4&gt;Http Method&lt;/h4&gt; DELETE
        /// <param name='largeFaceListId'>
        /// largeFaceListId of an existing large face list. Valid character is letter
        /// in lower case or digit or '-' or '_', maximum length is 64.
        /// </param>
        /// <param name='persistedFaceId'>
        /// persistedFaceId of an existing face. Valid character is letter in lower
        /// case or digit or '-' or '_', maximum length is 64.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveaOneFiveEightcEightadTwodeThreeSixOneSixcZeroEightSixfTwodFourWithHttpMessagesAsync(string largeFaceListId, string persistedFaceId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (largeFaceListId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "largeFaceListId");
            }
            if (persistedFaceId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "persistedFaceId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("largeFaceListId", largeFaceListId);
                tracingParameters.Add("persistedFaceId", persistedFaceId);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveaOneFiveEightcEightadTwodeThreeSixOneSixcZeroEightSixfTwodFour", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "largefacelists/{largeFaceListId}/persistedfaces/{persistedFaceId}").ToString();
            _url = _url.Replace("{largeFaceListId}", Uri.EscapeDataString(largeFaceListId));
            _url = _url.Replace("{persistedFaceId}", Uri.EscapeDataString(persistedFaceId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("DELETE");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// LargeFaceList - Get Face
        /// </summary>
        /// Retrieve persisted face in large face list by largeFaceListId and
        /// persistedFaceId.
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// GET
        /// <param name='largeFaceListId'>
        /// largeFaceListId of an existing large face list. Valid character is letter
        /// in lower case or digit or '-' or '_', maximum length is 64.
        /// </param>
        /// <param name='persistedFaceId'>
        /// persistedFaceId of an existing face. Valid character is letter in lower
        /// case or digit or '-' or '_', maximum length is 64.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveaOneFiveEightcfTwodTwodeThreeSixOneSixcZeroEightSixfTwodFiveWithHttpMessagesAsync(string largeFaceListId, string persistedFaceId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (largeFaceListId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "largeFaceListId");
            }
            if (persistedFaceId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "persistedFaceId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("largeFaceListId", largeFaceListId);
                tracingParameters.Add("persistedFaceId", persistedFaceId);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveaOneFiveEightcfTwodTwodeThreeSixOneSixcZeroEightSixfTwodFive", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "largefacelists/{largeFaceListId}/persistedfaces/{persistedFaceId}").ToString();
            _url = _url.Replace("{largeFaceListId}", Uri.EscapeDataString(largeFaceListId));
            _url = _url.Replace("{persistedFaceId}", Uri.EscapeDataString(persistedFaceId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// LargeFaceList - Update Face
        /// </summary>
        /// Update a specified face's userData field in a large face list by its
        /// persistedFaceId.
        /// &lt;h4&gt;Http Method&lt;/h4&gt;
        /// PATCH
        /// <param name='largeFaceListId'>
        /// largeFaceListId of an existing large face list. Valid character is letter
        /// in lower case or digit or '-' or '_', maximum length is 64.
        /// </param>
        /// <param name='persistedFaceId'>
        /// persistedFaceId of an existing face. Valid character is letter in lower
        /// case or digit or '-' or '_', maximum length is 64.
        /// </param>
        /// <param name='body'>
        /// User-specified data about the target face to add for any purpose. The
        /// maximum length is 1KB.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse> FiveaOneFiveEightecNinedTwodeThreeSixOneSixcZeroEightSixfTwodSevenWithHttpMessagesAsync(string largeFaceListId, string persistedFaceId, object body = default(object), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (largeFaceListId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "largeFaceListId");
            }
            if (persistedFaceId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "persistedFaceId");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("largeFaceListId", largeFaceListId);
                tracingParameters.Add("persistedFaceId", persistedFaceId);
                tracingParameters.Add("body", body);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "FiveaOneFiveEightecNinedTwodeThreeSixOneSixcZeroEightSixfTwodSeven", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new Uri(new Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "largefacelists/{largeFaceListId}/persistedfaces/{persistedFaceId}").ToString();
            _url = _url.Replace("{largeFaceListId}", Uri.EscapeDataString(largeFaceListId));
            _url = _url.Replace("{persistedFaceId}", Uri.EscapeDataString(persistedFaceId));
            // Create HTTP transport objects
            HttpRequestMessage _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("PATCH");
            _httpRequest.RequestUri = new Uri(_url);
            // Set Headers
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            if(body != null)
            {
                _requestContent = SafeJsonConvert.SerializeObject(body, this.SerializationSettings);
                _httpRequest.Content = new StringContent(_requestContent, Encoding.UTF8);
                _httpRequest.Content.Headers.ContentType = MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
            }
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 400 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 404 && (int)_statusCode != 415 && (int)_statusCode != 429)
            {
                var ex = new HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

    }
}
